"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e={attribute:/\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,id:/#(?<name>[-\w\P{ASCII}]+)/gu,class:/\.(?<name>[-\w\P{ASCII}]+)/gu,comma:/\s*,\s*/g,combinator:/\s*[\s>+~]\s*/g,"pseudo-element":/::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,"pseudo-class":/:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,universal:/(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,type:/(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu},t=new Set(["combinator","comma"]),n=new Set(["not","is","where","has","matches","-moz-any","-webkit-any","nth-child","nth-last-child"]),s=/(?<index>[\dn+-]+)\s+of\s+(?<subtree>.+)/,r={"nth-child":s,"nth-last-child":s},o=t=>{switch(t){case"pseudo-element":case"pseudo-class":return new RegExp(e[t].source.replace("(?<argument>¶*)","(?<argument>.*)"),"gu");default:return e[t]}};function c(e,t){let n=0,s="";for(;t<e.length;t++){const r=e[t];switch(r){case"(":++n;break;case")":--n}if(s+=r,0===n)return s}return s}function i(n,s=e){if(!n)return[];const r=[n];for(const[e,t]of Object.entries(s))for(let n=0;n<r.length;n++){const s=r[n];if("string"!=typeof s)continue;t.lastIndex=0;const o=t.exec(s);if(!o)continue;const c=o.index-1,i=[],a=o[0],l=s.slice(0,c+1);l&&i.push(l),i.push({...o.groups,type:e,content:a});const u=s.slice(c+a.length+1);u&&i.push(u),r.splice(n,1,...i)}let o=0;for(const e of r)switch(typeof e){case"string":throw new Error(`Unexpected sequence ${e} found at index ${o}`);case"object":o+=e.content.length,e.pos=[o-e.content.length,o],t.has(e.type)&&(e.content=e.content.trim()||" ")}return r}const a=/(['"])([^\\\n]+?)\1/g,l=/\\./g;function u(t,n=e){if(""===(t=t.trim()))return[];const s=[];t=(t=t.replace(l,((e,t)=>(s.push({value:e,offset:t}),"".repeat(e.length))))).replace(a,((e,t,n,r)=>(s.push({value:e,offset:r}),`${t}${"".repeat(n.length)}${t}`)));{let e,n=0;for(;(e=t.indexOf("(",n))>-1;){const r=c(t,e);s.push({value:r,offset:e}),t=`${t.substring(0,e)}(${"¶".repeat(r.length-2)})${t.substring(e+r.length)}`,n=e+r.length}}const r=i(t,n),u=new Set;for(const e of s.reverse())for(const t of r){const{offset:n,value:s}=e;if(!(t.pos[0]<=n&&n+s.length<=t.pos[1]))continue;const{content:r}=t,o=n-t.pos[0];t.content=r.slice(0,o)+s+r.slice(o+s.length),t.content!==r&&u.add(t)}for(const e of u){const t=o(e.type);if(!t)throw new Error(`Unknown token type: ${e.type}`);t.lastIndex=0;const n=t.exec(e.content);if(!n)throw new Error(`Unable to parse content for ${e.type}: ${e.content}`);Object.assign(e,n.groups)}return r}function p(e,{list:t=!0}={}){if(t&&e.find((e=>"comma"===e.type))){const t=[],n=[];for(let s=0;s<e.length;s++)if("comma"===e[s].type){if(0===n.length)throw new Error("Incorrect comma at "+s);t.push(p(n,{list:!1})),n.length=0}else n.push(e[s]);if(0===n.length)throw new Error("Trailing comma");return t.push(p(n,{list:!1})),{type:"list",list:t}}for(let t=e.length-1;t>=0;t--){let n=e[t];if("combinator"===n.type){let s=e.slice(0,t),r=e.slice(t+1);return 0===s.length?{type:"relative",combinator:n.content,right:p(r)}:{type:"complex",combinator:n.content,left:p(s),right:p(r)}}}switch(e.length){case 0:throw new Error("Could not build AST.");case 1:return e[0];default:return{type:"compound",list:[...e]}}}function*f(e,t){switch(e.type){case"list":for(let t of e.list)yield*f(t,e);break;case"complex":yield*f(e.left,e),yield*f(e.right,e);break;case"relative":yield*f(e.right,e);break;case"compound":yield*e.list.map((t=>[t,e]));break;default:yield[e,t]}}function h(e,{recursive:t=!0,list:s=!0}={}){const o=u(e);if(!o)return;const c=p(o,{list:s});if(!t)return c;for(const[e]of f(c)){if("pseudo-class"!==e.type||!e.argument)continue;if(!n.has(e.name))continue;let t=e.argument;const s=r[e.name];if(s){const n=s.exec(t);if(!n)continue;Object.assign(e,n.groups),t=n.groups.subtree}t&&Object.assign(e,{subtree:h(t,{recursive:!0,list:!0})})}return c}function m(e,t){return t=t||Math.max(...e)+1,e[0]*(t<<1)+e[1]*t+e[2]}exports.RECURSIVE_PSEUDO_CLASSES=n,exports.RECURSIVE_PSEUDO_CLASSES_ARGS=r,exports.TOKENS=e,exports.TRIM_TOKENS=t,exports.flatten=f,exports.gobbleParens=c,exports.parse=h,exports.specificity=function e(t){let s=t;if("string"==typeof s&&(s=h(s,{recursive:!0})),!s)return[];if("list"===s.type&&"list"in s){let t=10;const n=s.list.map((n=>{const s=e(n);return t=Math.max(t,...e(n)),s})),r=n.map((e=>m(e,t)));return n[r.indexOf(Math.max(...r))]}const r=[0,0,0];for(const[t]of f(s))switch(t.type){case"id":r[0]++;break;case"class":case"attribute":r[1]++;break;case"pseudo-element":case"type":r[2]++;break;case"pseudo-class":if("where"===t.name)break;if(!n.has(t.name)||!t.subtree){r[1]++;break}e(t.subtree).forEach(((e,t)=>r[t]+=e)),"nth-child"!==t.name&&"nth-last-child"!==t.name||r[1]++}return r},exports.specificityToNumber=m,exports.stringify=function e(t){if(Array.isArray(t))return t.map((e=>e.content)).join("");switch(t.type){case"list":return t.list.map(e).join(",");case"relative":return t.combinator+e(t.right);case"complex":return e(t.left)+t.combinator+e(t.right);case"compound":return t.list.map(e).join("");default:return t.content}},exports.tokenize=u,exports.tokenizeBy=i,exports.walk=function(e,t,n){if(e)for(const[s,r]of f(e,n))t(s,r)};
