"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isItemPinned = exports.isFeatureActive = exports.isComplementaryAreaLoading = exports.getActiveComplementaryArea = void 0;
exports.isModalActive = isModalActive;
var _data = require("@wordpress/data");
var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));
var _preferences = require("@wordpress/preferences");
var _deprecated2 = require("./deprecated");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Returns the complementary area that is active in a given scope.
 *
 * @param {Object} state Global application state.
 * @param {string} scope Item scope.
 *
 * @return {string | null | undefined} The complementary area that is active in the given scope.
 */
const getActiveComplementaryArea = exports.getActiveComplementaryArea = (0, _data.createRegistrySelector)(select => (state, scope) => {
  scope = (0, _deprecated2.normalizeComplementaryAreaScope)(scope);
  const isComplementaryAreaVisible = select(_preferences.store).get(scope, 'isComplementaryAreaVisible');

  // Return `undefined` to indicate that the user has never toggled
  // visibility, this is the vanilla default. Other code relies on this
  // nuance in the return value.
  if (isComplementaryAreaVisible === undefined) {
    return undefined;
  }

  // Return `null` to indicate the user hid the complementary area.
  if (isComplementaryAreaVisible === false) {
    return null;
  }
  return state?.complementaryAreas?.[scope];
});
const isComplementaryAreaLoading = exports.isComplementaryAreaLoading = (0, _data.createRegistrySelector)(select => (state, scope) => {
  scope = (0, _deprecated2.normalizeComplementaryAreaScope)(scope);
  const isVisible = select(_preferences.store).get(scope, 'isComplementaryAreaVisible');
  const identifier = state?.complementaryAreas?.[scope];
  return isVisible && identifier === undefined;
});

/**
 * Returns a boolean indicating if an item is pinned or not.
 *
 * @param {Object} state Global application state.
 * @param {string} scope Scope.
 * @param {string} item  Item to check.
 *
 * @return {boolean} True if the item is pinned and false otherwise.
 */
const isItemPinned = exports.isItemPinned = (0, _data.createRegistrySelector)(select => (state, scope, item) => {
  var _pinnedItems$item;
  scope = (0, _deprecated2.normalizeComplementaryAreaScope)(scope);
  item = (0, _deprecated2.normalizeComplementaryAreaName)(scope, item);
  const pinnedItems = select(_preferences.store).get(scope, 'pinnedItems');
  return (_pinnedItems$item = pinnedItems?.[item]) !== null && _pinnedItems$item !== void 0 ? _pinnedItems$item : true;
});

/**
 * Returns a boolean indicating whether a feature is active for a particular
 * scope.
 *
 * @param {Object} state       The store state.
 * @param {string} scope       The scope of the feature (e.g. core/edit-post).
 * @param {string} featureName The name of the feature.
 *
 * @return {boolean} Is the feature enabled?
 */
const isFeatureActive = exports.isFeatureActive = (0, _data.createRegistrySelector)(select => (state, scope, featureName) => {
  (0, _deprecated.default)(`select( 'core/interface' ).isFeatureActive( scope, featureName )`, {
    since: '6.0',
    alternative: `select( 'core/preferences' ).get( scope, featureName )`
  });
  return !!select(_preferences.store).get(scope, featureName);
});

/**
 * Returns true if a modal is active, or false otherwise.
 *
 * @param {Object} state     Global application state.
 * @param {string} modalName A string that uniquely identifies the modal.
 *
 * @return {boolean} Whether the modal is active.
 */
function isModalActive(state, modalName) {
  return state.activeModal === modalName;
}
//# sourceMappingURL=selectors.js.map