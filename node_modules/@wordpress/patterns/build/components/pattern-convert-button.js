"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PatternConvertButton;
var _blocks = require("@wordpress/blocks");
var _blockEditor = require("@wordpress/block-editor");
var _element = require("@wordpress/element");
var _components = require("@wordpress/components");
var _icons = require("@wordpress/icons");
var _data = require("@wordpress/data");
var _coreData = require("@wordpress/core-data");
var _i18n = require("@wordpress/i18n");
var _notices = require("@wordpress/notices");
var _store = require("../store");
var _createPatternModal = _interopRequireDefault(require("./create-pattern-modal"));
var _lockUnlock = require("../lock-unlock");
var _constants = require("../constants");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Menu control to convert block(s) to a pattern block.
 *
 * @param {Object}   props                        Component props.
 * @param {string[]} props.clientIds              Client ids of selected blocks.
 * @param {string}   props.rootClientId           ID of the currently selected top-level block.
 * @param {()=>void} props.closeBlockSettingsMenu Callback to close the block settings menu dropdown.
 * @return {import('react').ComponentType} The menu control or null.
 */function PatternConvertButton({
  clientIds,
  rootClientId,
  closeBlockSettingsMenu
}) {
  const {
    createSuccessNotice
  } = (0, _data.useDispatch)(_notices.store);
  const {
    replaceBlocks
  } = (0, _data.useDispatch)(_blockEditor.store);
  // Ignore reason: false positive of the lint rule.
  // eslint-disable-next-line @wordpress/no-unused-vars-before-return
  const {
    setEditingPattern
  } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
  const [isModalOpen, setIsModalOpen] = (0, _element.useState)(false);
  const canConvert = (0, _data.useSelect)(select => {
    var _getBlocksByClientId;
    const {
      canUser
    } = select(_coreData.store);
    const {
      getBlocksByClientId,
      canInsertBlockType,
      getBlockRootClientId
    } = select(_blockEditor.store);
    const rootId = rootClientId || (clientIds.length > 0 ? getBlockRootClientId(clientIds[0]) : undefined);
    const blocks = (_getBlocksByClientId = getBlocksByClientId(clientIds)) !== null && _getBlocksByClientId !== void 0 ? _getBlocksByClientId : [];

    // Check if the block has reusable support defined.
    const hasReusableBlockSupport = blockName => {
      const blockType = (0, _blocks.getBlockType)(blockName);
      const hasParent = blockType && 'parent' in blockType;

      // If the block has a parent, check with false as default, otherwise with true.
      return (0, _blocks.hasBlockSupport)(blockName, 'reusable', !hasParent);
    };
    const isReusable = blocks.length === 1 && blocks[0] && (0, _blocks.isReusableBlock)(blocks[0]) && !!select(_coreData.store).getEntityRecord('postType', 'wp_block', blocks[0].attributes.ref);
    const _canConvert =
    // Hide when this is already a synced pattern.
    !isReusable &&
    // Hide when patterns are disabled.
    canInsertBlockType('core/block', rootId) && blocks.every(block =>
    // Guard against the case where a regular block has *just* been converted.
    !!block &&
    // Hide on invalid blocks.
    block.isValid &&
    // Hide when block doesn't support being made into a pattern.
    hasReusableBlockSupport(block.name)) &&
    // Hide when current doesn't have permission to do that.
    // Blocks refers to the wp_block post type, this checks the ability to create a post of that type.
    !!canUser('create', {
      kind: 'postType',
      name: 'wp_block'
    });
    return _canConvert;
  }, [clientIds, rootClientId]);
  const {
    getBlocksByClientId
  } = (0, _data.useSelect)(_blockEditor.store);
  const getContent = (0, _element.useCallback)(() => (0, _blocks.serialize)(getBlocksByClientId(clientIds)), [getBlocksByClientId, clientIds]);
  if (!canConvert) {
    return null;
  }
  const handleSuccess = ({
    pattern
  }) => {
    if (pattern.wp_pattern_sync_status !== _constants.PATTERN_SYNC_TYPES.unsynced) {
      const newBlock = (0, _blocks.createBlock)('core/block', {
        ref: pattern.id
      });
      replaceBlocks(clientIds, newBlock);
      setEditingPattern(newBlock.clientId, true);
      closeBlockSettingsMenu();
    }
    createSuccessNotice(pattern.wp_pattern_sync_status === _constants.PATTERN_SYNC_TYPES.unsynced ? (0, _i18n.sprintf)(
    // translators: %s: the name the user has given to the pattern.
    (0, _i18n.__)('Unsynced pattern created: %s'), pattern.title.raw) : (0, _i18n.sprintf)(
    // translators: %s: the name the user has given to the pattern.
    (0, _i18n.__)('Synced pattern created: %s'), pattern.title.raw), {
      type: 'snackbar',
      id: 'convert-to-pattern-success'
    });
    setIsModalOpen(false);
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.MenuItem, {
      icon: _icons.symbol,
      onClick: () => setIsModalOpen(true),
      "aria-expanded": isModalOpen,
      "aria-haspopup": "dialog",
      children: (0, _i18n.__)('Create pattern')
    }), isModalOpen && /*#__PURE__*/(0, _jsxRuntime.jsx)(_createPatternModal.default, {
      content: getContent,
      onSuccess: pattern => {
        handleSuccess(pattern);
      },
      onError: () => {
        setIsModalOpen(false);
      },
      onClose: () => {
        setIsModalOpen(false);
      }
    })]
  });
}
//# sourceMappingURL=pattern-convert-button.js.map