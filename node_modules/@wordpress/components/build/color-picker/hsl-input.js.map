{"version":3,"names":["_colord","require","_element","_inputWithSlider","_jsxRuntime","HslInput","color","onChange","enableAlpha","colorPropHSLA","useMemo","toHsl","internalHSLA","setInternalHSLA","useState","isInternalColorSameAsReceivedColor","isEqual","colord","useEffect","colorValue","updateHSLAValue","partialNewValue","nextOnChangeValue","prevHSLA","jsxs","Fragment","children","jsx","InputWithSlider","min","max","label","abbreviation","value","h","nextH","s","nextS","l","nextL","Math","trunc","a","nextA","exports"],"sources":["@wordpress/components/src/color-picker/hsl-input.tsx"],"sourcesContent":["/**\n * External dependencies\n */\nimport { colord } from 'colord';\n\n/**\n * WordPress dependencies\n */\nimport { useState, useEffect, useMemo } from '@wordpress/element';\n\n/**\n * Internal dependencies\n */\nimport { InputWithSlider } from './input-with-slider';\nimport type { HslInputProps } from './types';\n\nexport const HslInput = ( { color, onChange, enableAlpha }: HslInputProps ) => {\n\tconst colorPropHSLA = useMemo( () => color.toHsl(), [ color ] );\n\n\tconst [ internalHSLA, setInternalHSLA ] = useState( { ...colorPropHSLA } );\n\n\tconst isInternalColorSameAsReceivedColor = color.isEqual(\n\t\tcolord( internalHSLA )\n\t);\n\n\tuseEffect( () => {\n\t\tif ( ! isInternalColorSameAsReceivedColor ) {\n\t\t\t// Keep internal HSLA color up to date with the received color prop\n\t\t\tsetInternalHSLA( colorPropHSLA );\n\t\t}\n\t}, [ colorPropHSLA, isInternalColorSameAsReceivedColor ] );\n\n\t// If the internal color is equal to the received color prop, we can use the\n\t// HSLA values from the local state which, compared to the received color prop,\n\t// retain more details about the actual H and S values that the user selected,\n\t// and thus allow for better UX when interacting with the H and S sliders.\n\tconst colorValue = isInternalColorSameAsReceivedColor\n\t\t? internalHSLA\n\t\t: colorPropHSLA;\n\n\tconst updateHSLAValue = (\n\t\tpartialNewValue: Partial< typeof colorPropHSLA >\n\t) => {\n\t\tconst nextOnChangeValue = colord( {\n\t\t\t...colorValue,\n\t\t\t...partialNewValue,\n\t\t} );\n\n\t\t// Fire `onChange` only if the resulting color is different from the\n\t\t// current one.\n\t\t// Otherwise, update the internal HSLA color to cause a re-render.\n\t\tif ( ! color.isEqual( nextOnChangeValue ) ) {\n\t\t\tonChange( nextOnChangeValue );\n\t\t} else {\n\t\t\tsetInternalHSLA( ( prevHSLA ) => ( {\n\t\t\t\t...prevHSLA,\n\t\t\t\t...partialNewValue,\n\t\t\t} ) );\n\t\t}\n\t};\n\n\treturn (\n\t\t<>\n\t\t\t<InputWithSlider\n\t\t\t\tmin={ 0 }\n\t\t\t\tmax={ 359 }\n\t\t\t\tlabel=\"Hue\"\n\t\t\t\tabbreviation=\"H\"\n\t\t\t\tvalue={ colorValue.h }\n\t\t\t\tonChange={ ( nextH: number ) => {\n\t\t\t\t\tupdateHSLAValue( { h: nextH } );\n\t\t\t\t} }\n\t\t\t/>\n\t\t\t<InputWithSlider\n\t\t\t\tmin={ 0 }\n\t\t\t\tmax={ 100 }\n\t\t\t\tlabel=\"Saturation\"\n\t\t\t\tabbreviation=\"S\"\n\t\t\t\tvalue={ colorValue.s }\n\t\t\t\tonChange={ ( nextS: number ) => {\n\t\t\t\t\tupdateHSLAValue( { s: nextS } );\n\t\t\t\t} }\n\t\t\t/>\n\t\t\t<InputWithSlider\n\t\t\t\tmin={ 0 }\n\t\t\t\tmax={ 100 }\n\t\t\t\tlabel=\"Lightness\"\n\t\t\t\tabbreviation=\"L\"\n\t\t\t\tvalue={ colorValue.l }\n\t\t\t\tonChange={ ( nextL: number ) => {\n\t\t\t\t\tupdateHSLAValue( { l: nextL } );\n\t\t\t\t} }\n\t\t\t/>\n\t\t\t{ enableAlpha && (\n\t\t\t\t<InputWithSlider\n\t\t\t\t\tmin={ 0 }\n\t\t\t\t\tmax={ 100 }\n\t\t\t\t\tlabel=\"Alpha\"\n\t\t\t\t\tabbreviation=\"A\"\n\t\t\t\t\tvalue={ Math.trunc( 100 * colorValue.a ) }\n\t\t\t\t\tonChange={ ( nextA: number ) => {\n\t\t\t\t\t\tupdateHSLAValue( { a: nextA / 100 } );\n\t\t\t\t\t} }\n\t\t\t\t/>\n\t\t\t) }\n\t\t</>\n\t);\n};\n"],"mappings":"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","ignoreList":[]}