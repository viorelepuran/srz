"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Fill;
var _compose = require("@wordpress/compose");
var _element = require("@wordpress/element");
var _slotFillContext = _interopRequireDefault(require("./slot-fill-context"));
var _styleProvider = _interopRequireDefault(require("../../style-provider"));
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function Fill({
  name,
  children
}) {
  var _slot$fillProps;
  const registry = (0, _element.useContext)(_slotFillContext.default);
  const slot = (0, _compose.useObservableValue)(registry.slots, name);
  const instanceRef = (0, _element.useRef)({});

  // We register fills so we can keep track of their existence.
  // Slots can use the `useSlotFills` hook to know if there're already fills
  // registered so they can choose to render themselves or not.
  (0, _element.useEffect)(() => {
    const instance = instanceRef.current;
    registry.registerFill(name, instance);
    return () => registry.unregisterFill(name, instance);
  }, [registry, name]);
  if (!slot || !slot.ref.current) {
    return null;
  }

  // When using a `Fill`, the `children` will be rendered in the document of the
  // `Slot`. This means that we need to wrap the `children` in a `StyleProvider`
  // to make sure we're referencing the right document/iframe (instead of the
  // context of the `Fill`'s parent).
  const wrappedChildren = /*#__PURE__*/(0, _jsxRuntime.jsx)(_styleProvider.default, {
    document: slot.ref.current.ownerDocument,
    children: typeof children === 'function' ? children((_slot$fillProps = slot.fillProps) !== null && _slot$fillProps !== void 0 ? _slot$fillProps : {}) : children
  });
  return (0, _element.createPortal)(wrappedChildren, slot.ref.current);
}
//# sourceMappingURL=fill.js.map