"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tabs = void 0;
var Ariakit = _interopRequireWildcard(require("@ariakit/react"));
var _compose = require("@wordpress/compose");
var _element = require("@wordpress/element");
var _i18n = require("@wordpress/i18n");
var _context = require("./context");
var _tab = require("./tab");
var _tablist = require("./tablist");
var _tabpanel = require("./tabpanel");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function externalToInternalTabId(externalId, instanceId) {
  return externalId && `${instanceId}-${externalId}`;
}
function internalToExternalTabId(internalId, instanceId) {
  return typeof internalId === 'string' ? internalId.replace(`${instanceId}-`, '') : internalId;
}

/**
 * Tabs is a collection of React components that combine to render
 * an [ARIA-compliant tabs pattern](https://www.w3.org/WAI/ARIA/apg/patterns/tabs/).
 *
 * Tabs organizes content across different screens, data sets, and interactions.
 * It has two sections: a list of tabs, and the view to show when a tab is chosen.
 *
 * `Tabs` itself is a wrapper component and context provider.
 * It is responsible for managing the state of the tabs, and rendering one instance of the `Tabs.TabList` component and one or more instances of the `Tab.TabPanel` component.
 */
const Tabs = exports.Tabs = Object.assign(function Tabs({
  selectOnMove = true,
  defaultTabId,
  orientation = 'horizontal',
  onSelect,
  children,
  selectedTabId,
  activeTabId,
  defaultActiveTabId,
  onActiveTabIdChange
}) {
  const instanceId = (0, _compose.useInstanceId)(Tabs, 'tabs');
  const store = Ariakit.useTabStore({
    selectOnMove,
    orientation,
    defaultSelectedId: externalToInternalTabId(defaultTabId, instanceId),
    setSelectedId: newSelectedId => {
      onSelect?.(internalToExternalTabId(newSelectedId, instanceId));
    },
    selectedId: externalToInternalTabId(selectedTabId, instanceId),
    defaultActiveId: externalToInternalTabId(defaultActiveTabId, instanceId),
    setActiveId: newActiveId => {
      onActiveTabIdChange?.(internalToExternalTabId(newActiveId, instanceId));
    },
    activeId: externalToInternalTabId(activeTabId, instanceId),
    rtl: (0, _i18n.isRTL)()
  });
  const {
    items,
    activeId
  } = Ariakit.useStoreState(store);
  const {
    setActiveId
  } = store;
  (0, _element.useEffect)(() => {
    requestAnimationFrame(() => {
      const focusedElement = items?.[0]?.element?.ownerDocument.activeElement;
      if (!focusedElement || !items.some(item => focusedElement === item.element)) {
        return; // Return early if no tabs are focused.
      }

      // If, after ariakit re-computes the active tab, that tab doesn't match
      // the currently focused tab, then we force an update to ariakit to avoid
      // any mismatches, especially when navigating to previous/next tab with
      // arrow keys.
      if (activeId !== focusedElement.id) {
        setActiveId(focusedElement.id);
      }
    });
  }, [activeId, items, setActiveId]);
  const contextValue = (0, _element.useMemo)(() => ({
    store,
    instanceId
  }), [store, instanceId]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_context.TabsContext.Provider, {
    value: contextValue,
    children: children
  });
}, {
  /**
   * Renders a single tab.
   *
   * The currently active tab receives default styling that can be
   * overridden with CSS targeting `[aria-selected="true"]`.
   */
  Tab: Object.assign(_tab.Tab, {
    displayName: 'Tabs.Tab'
  }),
  /**
   * A wrapper component for the `Tab` components.
   *
   * It is responsible for rendering the list of tabs.
   */
  TabList: Object.assign(_tablist.TabList, {
    displayName: 'Tabs.TabList'
  }),
  /**
   * Renders the content to display for a single tab once that tab is selected.
   */
  TabPanel: Object.assign(_tabpanel.TabPanel, {
    displayName: 'Tabs.TabPanel'
  }),
  Context: Object.assign(_context.TabsContext, {
    displayName: 'Tabs.Context'
  })
});
//# sourceMappingURL=index.js.map