{"version":3,"names":[],"sources":["@wordpress/components/src/composite/types.ts"],"sourcesContent":["/**\n * External dependencies\n */\nimport type * as Ariakit from '@ariakit/react';\n\nexport type CompositeContextProps = {\n\t/**\n\t * The component store, used for advanced usage of the component.\n\t *\n\t * _Note: Using the store directly is not recommended. Instead, use the props\n\t * exposed by the `Composite` component._\n\t *\n\t */\n\tstore?: unknown;\n};\n\ntype CompositeStoreProps = {\n\t/**\n\t * The current active item `id`. The active item is the element within the\n\t * composite widget that has either DOM or virtual focus (in case\n\t * the `virtualFocus` prop is enabled).\n\t * - `null` represents the base composite element (the one with a [composite\n\t *   role](https://w3c.github.io/aria/#composite)). Users will be able to\n\t *   navigate out of it using arrow keys.\n\t * - If `activeId` is initially set to `null`, the base composite element\n\t *   itself will have focus and users will be able to navigate to it using\n\t *   arrow keys.\n\t */\n\tactiveId?: Ariakit.CompositeStoreProps[ 'activeId' ];\n\t/**\n\t * The composite item id that should be active by default when the composite\n\t * widget is rendered. If `null`, the composite element itself will have focus\n\t * and users will be able to navigate to it using arrow keys. If `undefined`,\n\t * the first enabled item will be focused.\n\t */\n\tdefaultActiveId?: Ariakit.CompositeStoreProps[ 'defaultActiveId' ];\n\t/**\n\t * A callback that gets called when the `activeId` state changes.\n\t */\n\tsetActiveId?: Ariakit.CompositeStoreProps[ 'setActiveId' ];\n\t/**\n\t * Determines how the focus behaves when the user reaches the end of the\n\t * composite widget.\n\t *\n\t * On one-dimensional composite widgets:\n\t * - `true` loops from the last item to the first item and vice-versa.\n\t * - `horizontal` loops only if `orientation` is `horizontal` or not set.\n\t * - `vertical` loops only if `orientation` is `vertical` or not set.\n\t * - If `activeId` is initially set to `null`, the composite element will\n\t *   be focused in between the last and first items.\n\t *\n\t * On two-dimensional composite widgets (ie. when using `CompositeRow`):\n\t * - `true` loops from the last row/column item to the first item in the same\n\t *   row/column and vice-versa. If it's the last item in the last row, it\n\t *   moves to the first item in the first row and vice-versa.\n\t * - `horizontal` loops only from the last row item to the first item in the\n\t *   same row.\n\t * - `vertical` loops only from the last column item to the first item in the\n\t *   column row.\n\t * - If `activeId` is initially set to `null`, vertical loop will have no\n\t *   effect as moving down from the last row or up from the first row will\n\t *   focus on the composite element.\n\t * - If `focusWrap` matches the value of `focusLoop`, it'll wrap between the\n\t *   last item in the last row or column and the first item in the first row or\n\t *   column and vice-versa.\n\t *\n\t * @default false\n\t */\n\tfocusLoop?: Ariakit.CompositeStoreProps[ 'focusLoop' ];\n\t/**\n\t * **Works only on two-dimensional composite widgets**.\n\t *\n\t * If enabled, moving to the next item from the last one in a row or column\n\t * will focus on the first item in the next row or column and vice-versa.\n\t * - `true` wraps between rows and columns.\n\t * - `horizontal` wraps only between rows.\n\t * - `vertical` wraps only between columns.\n\t * - If `focusLoop` matches the value of `focusWrap`, it'll wrap between the\n\t *   last item in the last row or column and the first item in the first row or\n\t *   column and vice-versa.\n\t *\n\t * @default false\n\t */\n\tfocusWrap?: Ariakit.CompositeStoreProps[ 'focusWrap' ];\n\t/**\n\t * **Works only on two-dimensional composite widgets**.\n\t *\n\t * If enabled, moving up or down when there's no next item or when the next\n\t * item is disabled will shift to the item right before it.\n\t *\n\t * @default false\n\t */\n\tfocusShift?: Ariakit.CompositeStoreProps[ 'focusShift' ];\n\t/**\n\t * If enabled, the composite element will act as an\n\t * [`aria-activedescendant`](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant)\n\t * container instead of [roving\n\t * tabindex](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex).\n\t * DOM focus will remain on the composite element while its items receive\n\t * virtual focus.\n\t *\n\t * In both scenarios, the item in focus will carry the `data-active-item`\n\t * attribute.\n\t *\n\t * @default false\n\t */\n\tvirtualFocus?: Ariakit.CompositeStoreProps[ 'virtualFocus' ];\n\t/**\n\t * Defines the orientation of the composite widget. If the composite has a\n\t * single row or column (one-dimensional), the `orientation` value determines\n\t * which arrow keys can be used to move focus:\n\t * - `both`: all arrow keys work.\n\t * - `horizontal`: only left and right arrow keys work.\n\t * - `vertical`: only up and down arrow keys work.\n\t *\n\t * It doesn't have any effect on two-dimensional composites.\n\t *\n\t * @default \"both\"\n\t */\n\torientation?: Ariakit.CompositeStoreProps[ 'orientation' ];\n\t/**\n\t * Controls how the previous and next items are determined.\n\t * If `rtl` is set to `true`, they will be inverted.\n\t *\n\t * This only affects the composite widget behavior. You still need to set\n\t * `dir=\"rtl\"` on HTML/CSS.\n\t *\n\t * @default `isRtl()`\n\t */\n\trtl?: Ariakit.CompositeStoreProps[ 'rtl' ];\n};\n\nexport type CompositeProps = CompositeStoreProps & {\n\t/**\n\t * Allows the component to be rendered as a different HTML element or React\n\t * component. The value can be a React element or a function that takes in the\n\t * original component props and gives back a React element with the props\n\t * merged.\n\t */\n\trender?: Ariakit.CompositeProps[ 'render' ];\n\t/**\n\t * Makes the component a focusable element. When this element gains keyboard\n\t * focus, it gets a `data-focus-visible` attribute and triggers the\n\t * `onFocusVisible` prop.\n\t * The component supports the `disabled` prop even for those elements not\n\t * supporting the native `disabled` attribute. Disabled elements may be\n\t * still accessible via keyboard by using the the `accessibleWhenDisabled`\n\t * prop.\n\t * Non-native focusable elements will lose their focusability entirely.\n\t * However, native focusable elements will retain their inherent focusability.\n\t */\n\tfocusable?: Ariakit.CompositeProps[ 'focusable' ];\n\t/**\n\t * Determines if the element is disabled. This sets the `aria-disabled`\n\t * attribute accordingly, enabling support for all elements, including those\n\t * that don't support the native `disabled` attribute.\n\t *\n\t * This feature can be combined with the `accessibleWhenDisabled` prop to\n\t * make disabled elements still accessible via keyboard.\n\t *\n\t * **Note**: For this prop to work, the `focusable` prop must be set to\n\t * `true`, if it's not set by default.\n\t *\n\t * @default false\n\t */\n\tdisabled?: Ariakit.CompositeProps[ 'disabled' ];\n\t/**\n\t * Indicates whether the element should be focusable even when it is\n\t * `disabled`.\n\t *\n\t * This is important when discoverability is a concern. For example:\n\t *\n\t * > A toolbar in an editor contains a set of special smart paste functions\n\t * that are disabled when the clipboard is empty or when the function is not\n\t * applicable to the current content of the clipboard. It could be helpful to\n\t * keep the disabled buttons focusable if the ability to discover their\n\t * functionality is primarily via their presence on the toolbar.\n\t *\n\t * Learn more on [Focusability of disabled\n\t * controls](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols).\n\t */\n\taccessibleWhenDisabled?: Ariakit.CompositeProps[ 'accessibleWhenDisabled' ];\n\t/**\n\t * Custom event handler invoked when the element gains focus through keyboard\n\t * interaction or a key press occurs while the element is in focus. This is\n\t * the programmatic equivalent of the `data-focus-visible` attribute.\n\t *\n\t * **Note**: For this prop to work, the `focusable` prop must be set to `true`\n\t * if it's not set by default.\n\t */\n\tonFocusVisible?: Ariakit.CompositeProps[ 'onFocusVisible' ];\n\t/**\n\t * The contents of the component.\n\t */\n\tchildren?: Ariakit.CompositeProps[ 'children' ];\n};\n\nexport type CompositeGroupProps = {\n\t/**\n\t * Allows the component to be rendered as a different HTML element or React\n\t * component. The value can be a React element or a function that takes in the\n\t * original component props and gives back a React element with the props\n\t * merged.\n\t */\n\trender?: Ariakit.CompositeGroupProps[ 'render' ];\n\t/**\n\t * The contents of the component.\n\t */\n\tchildren?: Ariakit.CompositeGroupProps[ 'children' ];\n};\n\nexport type CompositeGroupLabelProps = {\n\t/**\n\t * Allows the component to be rendered as a different HTML element or React\n\t * component. The value can be a React element or a function that takes in the\n\t * original component props and gives back a React element with the props\n\t * merged.\n\t */\n\trender?: Ariakit.CompositeGroupLabelProps[ 'render' ];\n\t/**\n\t * The contents of the component.\n\t */\n\tchildren?: Ariakit.CompositeGroupLabelProps[ 'children' ];\n};\n\nexport type CompositeItemProps = {\n\t/**\n\t * Allows the component to be rendered as a different HTML element or React\n\t * component. The value can be a React element or a function that takes in the\n\t * original component props and gives back a React element with the props\n\t * merged.\n\t */\n\trender?: Ariakit.CompositeItemProps[ 'render' ];\n\t/**\n\t * The contents of the component.\n\t */\n\tchildren?: Ariakit.CompositeItemProps[ 'children' ];\n\t/**\n\t * Indicates whether the element should be focusable even when it is\n\t * `disabled`.\n\t *\n\t * This is important when discoverability is a concern. For example:\n\t *\n\t * > A toolbar in an editor contains a set of special smart paste functions\n\t * that are disabled when the clipboard is empty or when the function is not\n\t * applicable to the current content of the clipboard. It could be helpful to\n\t * keep the disabled buttons focusable if the ability to discover their\n\t * functionality is primarily via their presence on the toolbar.\n\t *\n\t * Learn more on [Focusability of disabled\n\t * controls](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols).\n\t */\n\taccessibleWhenDisabled?: Ariakit.CompositeItemProps[ 'accessibleWhenDisabled' ];\n};\n\nexport type CompositeRowProps = {\n\t/**\n\t * Allows the component to be rendered as a different HTML element or React\n\t * component. The value can be a React element or a function that takes in the\n\t * original component props and gives back a React element with the props\n\t * merged.\n\t */\n\trender?: Ariakit.CompositeRowProps[ 'render' ];\n\t/**\n\t * The contents of the component.\n\t */\n\tchildren?: Ariakit.CompositeRowProps[ 'children' ];\n};\n\nexport type CompositeHoverProps = {\n\t/**\n\t * Allows the component to be rendered as a different HTML element or React\n\t * component. The value can be a React element or a function that takes in the\n\t * original component props and gives back a React element with the props\n\t * merged.\n\t */\n\trender?: Ariakit.CompositeHoverProps[ 'render' ];\n\t/**\n\t * The contents of the component.\n\t */\n\tchildren?: Ariakit.CompositeHoverProps[ 'children' ];\n};\n\nexport type CompositeTypeaheadProps = {\n\t/**\n\t * Allows the component to be rendered as a different HTML element or React\n\t * component. The value can be a React element or a function that takes in the\n\t * original component props and gives back a React element with the props\n\t * merged.\n\t */\n\trender?: Ariakit.CompositeTypeaheadProps[ 'render' ];\n\t/**\n\t * The contents of the component.\n\t */\n\tchildren?: Ariakit.CompositeTypeaheadProps[ 'children' ];\n};\n"],"mappings":"","ignoreList":[]}