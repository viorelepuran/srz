"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BoxInputControl;
var _compose = require("@wordpress/compose");
var _i18n = require("@wordpress/i18n");
var _element = require("@wordpress/element");
var _icons = require("@wordpress/icons");
var _tooltip = _interopRequireDefault(require("../tooltip"));
var _utils = require("../unit-control/utils");
var _utils2 = require("./utils");
var _boxControlStyles = require("./styles/box-control-styles");
var _button = _interopRequireDefault(require("../button"));
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const noop = () => {};
function getSidesToModify(side, sides, isAlt) {
  const allowedSides = (0, _utils2.getAllowedSides)(sides);
  let modifiedSides = [];
  switch (side) {
    case 'all':
      modifiedSides = ['top', 'bottom', 'left', 'right'];
      break;
    case 'horizontal':
      modifiedSides = ['left', 'right'];
      break;
    case 'vertical':
      modifiedSides = ['top', 'bottom'];
      break;
    default:
      modifiedSides = [side];
  }
  if (isAlt) {
    switch (side) {
      case 'top':
        modifiedSides.push('bottom');
        break;
      case 'bottom':
        modifiedSides.push('top');
        break;
      case 'left':
        modifiedSides.push('left');
        break;
      case 'right':
        modifiedSides.push('right');
        break;
    }
  }
  return modifiedSides.filter(s => allowedSides.has(s));
}
function BoxInputControl({
  __next40pxDefaultSize,
  onChange = noop,
  onFocus = noop,
  values,
  selectedUnits,
  setSelectedUnits,
  sides,
  side,
  min = 0,
  presets,
  presetKey,
  ...props
}) {
  var _CUSTOM_VALUE_SETTING, _CUSTOM_VALUE_SETTING2;
  const defaultValuesToModify = getSidesToModify(side, sides);
  const handleOnFocus = event => {
    onFocus(event, {
      side
    });
  };
  const handleOnChange = nextValues => {
    onChange(nextValues);
  };
  const handleRawOnValueChange = next => {
    const nextValues = {
      ...values
    };
    defaultValuesToModify.forEach(modifiedSide => {
      nextValues[modifiedSide] = next;
    });
    handleOnChange(nextValues);
  };
  const handleOnValueChange = (next, extra) => {
    const nextValues = {
      ...values
    };
    const isNumeric = next !== undefined && !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    const modifiedSides = getSidesToModify(side, sides,
    /**
     * Supports changing pair sides. For example, holding the ALT key
     * when changing the TOP will also update BOTTOM.
     */
    // @ts-expect-error - TODO: event.altKey is only present when the change event was
    // triggered by a keyboard event. Should this feature be implemented differently so
    // it also works with drag events?
    !!extra?.event.altKey);
    modifiedSides.forEach(modifiedSide => {
      nextValues[modifiedSide] = nextValue;
    });
    handleOnChange(nextValues);
  };
  const handleOnUnitChange = next => {
    const newUnits = {
      ...selectedUnits
    };
    defaultValuesToModify.forEach(modifiedSide => {
      newUnits[modifiedSide] = next;
    });
    setSelectedUnits(newUnits);
  };
  const mergedValue = (0, _utils2.getMergedValue)(values, defaultValuesToModify);
  const hasValues = (0, _utils2.isValuesDefined)(values);
  const isMixed = hasValues && defaultValuesToModify.length > 1 && (0, _utils2.isValueMixed)(values, defaultValuesToModify);
  const [parsedQuantity, parsedUnit] = (0, _utils.parseQuantityAndUnitFromRawValue)(mergedValue);
  const computedUnit = hasValues ? parsedUnit : selectedUnits[defaultValuesToModify[0]];
  const generatedId = (0, _compose.useInstanceId)(BoxInputControl, 'box-control-input');
  const inputId = [generatedId, side].join('-');
  const isMixedUnit = defaultValuesToModify.length > 1 && mergedValue === undefined && defaultValuesToModify.some(s => selectedUnits[s] !== computedUnit);
  const usedValue = mergedValue === undefined && computedUnit ? computedUnit : mergedValue;
  const mixedPlaceholder = isMixed || isMixedUnit ? (0, _i18n.__)('Mixed') : undefined;
  const hasPresets = presets && presets.length > 0 && presetKey;
  const hasPresetValue = hasPresets && mergedValue !== undefined && !isMixed && (0, _utils2.isValuePreset)(mergedValue, presetKey);
  const [showCustomValueControl, setShowCustomValueControl] = (0, _element.useState)(!hasPresets || !hasPresetValue && !isMixed && mergedValue !== undefined);
  const presetIndex = hasPresetValue ? (0, _utils2.getPresetIndexFromValue)(mergedValue, presetKey, presets) : undefined;
  const marks = hasPresets ? [{
    value: 0,
    label: '',
    tooltip: (0, _i18n.__)('None')
  }].concat(presets.map((preset, index) => {
    var _preset$name;
    return {
      value: index + 1,
      label: '',
      tooltip: (_preset$name = preset.name) !== null && _preset$name !== void 0 ? _preset$name : preset.slug
    };
  })) : [];
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_boxControlStyles.InputWrapper, {
    expanded: true,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_boxControlStyles.FlexedBoxControlIcon, {
      side: side,
      sides: sides
    }), showCustomValueControl && /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_tooltip.default, {
        placement: "top-end",
        text: _utils2.LABELS[side],
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_boxControlStyles.StyledUnitControl, {
          ...props,
          min: min,
          __shouldNotWarnDeprecated36pxSize: true,
          __next40pxDefaultSize: __next40pxDefaultSize,
          className: "component-box-control__unit-control",
          id: inputId,
          isPressEnterToChange: true,
          disableUnits: isMixed || isMixedUnit,
          value: usedValue,
          onChange: handleOnValueChange,
          onUnitChange: handleOnUnitChange,
          onFocus: handleOnFocus,
          label: _utils2.LABELS[side],
          placeholder: mixedPlaceholder,
          hideLabelFromVision: true
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_boxControlStyles.FlexedRangeControl, {
        __nextHasNoMarginBottom: true,
        __next40pxDefaultSize: __next40pxDefaultSize,
        __shouldNotWarnDeprecated36pxSize: true,
        "aria-controls": inputId,
        label: _utils2.LABELS[side],
        hideLabelFromVision: true,
        onChange: newValue => {
          handleOnValueChange(newValue !== undefined ? [newValue, computedUnit].join('') : undefined);
        },
        min: isFinite(min) ? min : 0,
        max: (_CUSTOM_VALUE_SETTING = _utils2.CUSTOM_VALUE_SETTINGS[computedUnit !== null && computedUnit !== void 0 ? computedUnit : 'px']?.max) !== null && _CUSTOM_VALUE_SETTING !== void 0 ? _CUSTOM_VALUE_SETTING : 10,
        step: (_CUSTOM_VALUE_SETTING2 = _utils2.CUSTOM_VALUE_SETTINGS[computedUnit !== null && computedUnit !== void 0 ? computedUnit : 'px']?.step) !== null && _CUSTOM_VALUE_SETTING2 !== void 0 ? _CUSTOM_VALUE_SETTING2 : 0.1,
        value: parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : 0,
        withInputField: false
      })]
    }), hasPresets && !showCustomValueControl && /*#__PURE__*/(0, _jsxRuntime.jsx)(_boxControlStyles.FlexedRangeControl, {
      __next40pxDefaultSize: true,
      className: "spacing-sizes-control__range-control",
      value: presetIndex !== undefined ? presetIndex + 1 : 0,
      onChange: newIndex => {
        const newValue = newIndex === 0 || newIndex === undefined ? undefined : (0, _utils2.getPresetValueFromIndex)(newIndex - 1, presetKey, presets);
        handleRawOnValueChange(newValue);
      },
      withInputField: false,
      "aria-valuenow": presetIndex !== undefined ? presetIndex + 1 : 0,
      "aria-valuetext": marks[presetIndex !== undefined ? presetIndex + 1 : 0].tooltip,
      renderTooltipContent: index => marks[!index ? 0 : index].tooltip,
      min: 0,
      max: marks.length - 1,
      marks: marks,
      label: _utils2.LABELS[side],
      hideLabelFromVision: true,
      __nextHasNoMarginBottom: true
    }), hasPresets && /*#__PURE__*/(0, _jsxRuntime.jsx)(_button.default, {
      label: showCustomValueControl ? (0, _i18n.__)('Use size preset') : (0, _i18n.__)('Set custom size'),
      icon: _icons.settings,
      onClick: () => {
        setShowCustomValueControl(!showCustomValueControl);
      },
      isPressed: showCustomValueControl,
      size: "small",
      iconSize: 24
    })]
  }, `box-control-${side}`);
}
//# sourceMappingURL=input-control.js.map