{"version":3,"names":["_element","require","_compose","NULL_ELEMENT_OFFSET_RECT","exports","element","undefined","top","right","bottom","left","width","height","getElementOffsetRect","_offsetParent$getBoun","_offsetParent$scrollL","_offsetParent$scrollT","rect","getBoundingClientRect","offsetParent","offsetParentRect","offsetParentScrollX","scrollLeft","offsetParentScrollY","scrollTop","computedWidth","parseFloat","getComputedStyle","computedHeight","scaleX","scaleY","POLL_RATE","useTrackElementOffsetRect","targetElement","deps","indicatorPosition","setIndicatorPosition","useState","intervalRef","useRef","measure","useEvent","isConnected","elementOffsetRect","clearInterval","current","setElement","useResizeObserver","requestAnimationFrame","setInterval","useLayoutEffect"],"sources":["@wordpress/components/src/utils/element-rect.ts"],"sourcesContent":["/* eslint-disable jsdoc/require-param */\n/**\n * WordPress dependencies\n */\nimport { useLayoutEffect, useRef, useState } from '@wordpress/element';\nimport { useEvent, useResizeObserver } from '@wordpress/compose';\n\n/**\n * The position and dimensions of an element, relative to its offset parent.\n */\nexport type ElementOffsetRect = {\n\t/**\n\t * The element the rect belongs to.\n\t */\n\telement: HTMLElement | undefined;\n\t/**\n\t * The distance from the top edge of the offset parent to the top edge of\n\t * the element.\n\t */\n\ttop: number;\n\t/**\n\t * The distance from the right edge of the offset parent to the right edge\n\t * of the element.\n\t */\n\tright: number;\n\t/**\n\t * The distance from the bottom edge of the offset parent to the bottom edge\n\t * of the element.\n\t */\n\tbottom: number;\n\t/**\n\t * The distance from the left edge of the offset parent to the left edge of\n\t * the element.\n\t */\n\tleft: number;\n\t/**\n\t * The width of the element.\n\t */\n\twidth: number;\n\t/**\n\t * The height of the element.\n\t */\n\theight: number;\n};\n\n/**\n * An `ElementOffsetRect` object with all values set to zero.\n */\nexport const NULL_ELEMENT_OFFSET_RECT = {\n\telement: undefined,\n\ttop: 0,\n\tright: 0,\n\tbottom: 0,\n\tleft: 0,\n\twidth: 0,\n\theight: 0,\n} satisfies ElementOffsetRect;\n\n/**\n * Returns the position and dimensions of an element, relative to its offset\n * parent, with subpixel precision. Values reflect the real measures before any\n * potential scaling distortions along the X and Y axes.\n *\n * Useful in contexts where plain `getBoundingClientRect` calls or `ResizeObserver`\n * entries are not suitable, such as when the element is transformed, and when\n * `element.offset<Top|Left|Width|Height>` methods are not precise enough.\n *\n * **Note:** in some contexts, like when the scale is 0, this method will fail\n * because it's impossible to calculate a scaling ratio. When that happens, it\n * will return `undefined`.\n */\nexport function getElementOffsetRect(\n\telement: HTMLElement\n): ElementOffsetRect | undefined {\n\t// Position and dimension values computed with `getBoundingClientRect` have\n\t// subpixel precision, but are affected by distortions since they represent\n\t// the \"real\" measures, or in other words, the actual final values as rendered\n\t// by the browser.\n\tconst rect = element.getBoundingClientRect();\n\tif ( rect.width === 0 || rect.height === 0 ) {\n\t\treturn;\n\t}\n\tconst offsetParent = element.offsetParent;\n\tconst offsetParentRect =\n\t\toffsetParent?.getBoundingClientRect() ?? NULL_ELEMENT_OFFSET_RECT;\n\tconst offsetParentScrollX = offsetParent?.scrollLeft ?? 0;\n\tconst offsetParentScrollY = offsetParent?.scrollTop ?? 0;\n\n\t// Computed widths and heights have subpixel precision, and are not affected\n\t// by distortions.\n\tconst computedWidth = parseFloat( getComputedStyle( element ).width );\n\tconst computedHeight = parseFloat( getComputedStyle( element ).height );\n\n\t// We can obtain the current scale factor for the element by comparing \"computed\"\n\t// dimensions with the \"real\" ones.\n\tconst scaleX = computedWidth / rect.width;\n\tconst scaleY = computedHeight / rect.height;\n\n\treturn {\n\t\telement,\n\t\t// To obtain the adjusted values for the position:\n\t\t// 1. Compute the element's position relative to the offset parent.\n\t\t// 2. Correct for the scale factor.\n\t\t// 3. Adjust for the scroll position of the offset parent.\n\t\ttop:\n\t\t\t( rect.top - offsetParentRect?.top ) * scaleY + offsetParentScrollY,\n\t\tright:\n\t\t\t( offsetParentRect?.right - rect.right ) * scaleX -\n\t\t\toffsetParentScrollX,\n\t\tbottom:\n\t\t\t( offsetParentRect?.bottom - rect.bottom ) * scaleY -\n\t\t\toffsetParentScrollY,\n\t\tleft:\n\t\t\t( rect.left - offsetParentRect?.left ) * scaleX +\n\t\t\toffsetParentScrollX,\n\t\t// Computed dimensions don't need any adjustments.\n\t\twidth: computedWidth,\n\t\theight: computedHeight,\n\t};\n}\n\nconst POLL_RATE = 100;\n\n/**\n * Tracks the position and dimensions of an element, relative to its offset\n * parent. The element can be changed dynamically.\n *\n * When no element is provided (`null` or `undefined`), the hook will return\n * a \"null\" rect, in which all values are `0` and `element` is `undefined`.\n *\n * **Note:** sometimes, the measurement will fail (see `getElementOffsetRect`'s\n * documentation for more details). When that happens, this hook will attempt\n * to measure again after a frame, and if that fails, it will poll every 100\n * milliseconds until it succeeds.\n */\nexport function useTrackElementOffsetRect(\n\ttargetElement: HTMLElement | undefined | null,\n\tdeps: unknown[] = []\n) {\n\tconst [ indicatorPosition, setIndicatorPosition ] =\n\t\tuseState< ElementOffsetRect >( NULL_ELEMENT_OFFSET_RECT );\n\tconst intervalRef = useRef< ReturnType< typeof setInterval > >();\n\n\tconst measure = useEvent( () => {\n\t\t// Check that the targetElement is still attached to the DOM, in case\n\t\t// it was removed since the last `measure` call.\n\t\tif ( targetElement && targetElement.isConnected ) {\n\t\t\tconst elementOffsetRect = getElementOffsetRect( targetElement );\n\t\t\tif ( elementOffsetRect ) {\n\t\t\t\tsetIndicatorPosition( elementOffsetRect );\n\t\t\t\tclearInterval( intervalRef.current );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tclearInterval( intervalRef.current );\n\t\t}\n\t\treturn false;\n\t} );\n\n\tconst setElement = useResizeObserver( () => {\n\t\tif ( ! measure() ) {\n\t\t\trequestAnimationFrame( () => {\n\t\t\t\tif ( ! measure() ) {\n\t\t\t\t\tintervalRef.current = setInterval( measure, POLL_RATE );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\n\tuseLayoutEffect( () => {\n\t\tsetElement( targetElement );\n\t\tif ( ! targetElement ) {\n\t\t\tsetIndicatorPosition( NULL_ELEMENT_OFFSET_RECT );\n\t\t}\n\t}, [ setElement, targetElement ] );\n\n\t// Escape hatch to force a remeasurement when something else changes rather\n\t// than the target elements' ref or size (for example, the target element\n\t// can change its position within the tablist).\n\tuseLayoutEffect( () => {\n\t\tmeasure();\n\t\t// `measure` is a stable function, so it's safe to omit it from the deps array.\n\t\t// deps can't be statically analyzed by ESLint\n\t}, deps );\n\n\treturn indicatorPosition;\n}\n\n/* eslint-enable jsdoc/require-param */\n"],"mappings":"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","ignoreList":[]}