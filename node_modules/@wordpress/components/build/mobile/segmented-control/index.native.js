"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNative = require("react-native");
var _element = require("@wordpress/element");
var _compose = require("@wordpress/compose");
var _layoutAnimation = require("../layout-animation");
var _style = _interopRequireDefault(require("./style.scss"));
var _jsxRuntime = require("react/jsx-runtime");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const ANIMATION_DURATION = 200;
const isIOS = _reactNative.Platform.OS === 'ios';
const Segment = ({
  isSelected,
  title,
  onPress,
  onLayout,
  ...props
}) => {
  const isSelectedIOS = isIOS && isSelected;
  const segmentStyle = [_style.default.segment, isIOS && _style.default.segmentIOS];
  const textStyle = (0, _compose.usePreferredColorSchemeStyle)(_style.default.buttonTextDefault, _style.default.buttonTextDefaultDark);
  const selectedTextStyle = (0, _compose.usePreferredColorSchemeStyle)(_style.default.buttonTextSelected, _style.default.buttonTextSelectedDark);
  const shadowStyle = (0, _compose.usePreferredColorSchemeStyle)(_style.default.shadowIOS, {});
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
    style: isSelectedIOS && shadowStyle,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.TouchableWithoutFeedback, {
      onPress: onPress,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
        style: segmentStyle,
        onLayout: onLayout,
        ...props,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Text, {
          style: [textStyle, isSelected && selectedTextStyle],
          maxFontSizeMultiplier: 2,
          children: title
        })
      })
    })
  });
};
const SegmentedControls = ({
  segments,
  segmentHandler,
  selectedIndex,
  addonLeft,
  addonRight
}) => {
  const selectedSegmentIndex = selectedIndex || 0;
  const [activeSegmentIndex, setActiveSegmentIndex] = (0, _element.useState)(selectedSegmentIndex);
  const [segmentsDimensions, setSegmentsDimensions] = (0, _element.useState)({
    [activeSegmentIndex]: {
      width: 0,
      height: 0
    }
  });
  const [positionAnimationValue] = (0, _element.useState)(new _reactNative.Animated.Value(0));
  (0, _element.useEffect)(() => {
    setActiveSegmentIndex(selectedSegmentIndex);
    segmentHandler(segments[selectedSegmentIndex]);
    // See https://github.com/WordPress/gutenberg/pull/41166
  }, []);
  (0, _element.useEffect)(() => {
    positionAnimationValue.setValue(calculateEndValue(activeSegmentIndex));
    // See https://github.com/WordPress/gutenberg/pull/41166
  }, [segmentsDimensions]);
  const containerStyle = (0, _compose.usePreferredColorSchemeStyle)(_style.default.container, _style.default.containerDark);
  function performSwatchAnimation(index) {
    _reactNative.Animated.timing(positionAnimationValue, {
      toValue: calculateEndValue(index),
      duration: ANIMATION_DURATION,
      easing: _reactNative.Easing.ease,
      useNativeDriver: false
    }).start();
  }
  function calculateEndValue(index) {
    const {
      paddingLeft: offset
    } = isIOS ? _style.default.containerIOS : _style.default.container;
    const widths = Object.values(segmentsDimensions).map(dimension => dimension.width);
    const widthsDistance = widths.slice(0, index);
    const widthsDistanceSum = widthsDistance.reduce((sum, n) => sum + n, 0);
    const endValue = index === 0 ? 0 : widthsDistanceSum;
    return endValue + offset;
  }
  function onHandlePress(segment, index) {
    (0, _layoutAnimation.performLayoutAnimation)(ANIMATION_DURATION);
    setActiveSegmentIndex(index);
    segmentHandler(segment);
    performSwatchAnimation(index);
  }
  function segmentOnLayout(event, index) {
    const {
      width,
      height
    } = event.nativeEvent.layout;
    setSegmentsDimensions({
      ...segmentsDimensions,
      [index]: {
        width,
        height
      }
    });
  }
  const selectedStyle = (0, _compose.usePreferredColorSchemeStyle)(_style.default.selected, _style.default.selectedDark);
  const width = segmentsDimensions[activeSegmentIndex]?.width;
  const height = segmentsDimensions[activeSegmentIndex]?.height;
  const outlineStyle = [_style.default.outline, isIOS && _style.default.outlineIOS];
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
    style: _style.default.row,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
      style: _style.default.flex,
      children: addonLeft
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
      style: [containerStyle, isIOS && _style.default.containerIOS],
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Animated.View, {
        style: [{
          width,
          left: positionAnimationValue,
          height
        }, selectedStyle, outlineStyle]
      }), segments.map((segment, index) => {
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(Segment, {
          title: segment,
          onPress: () => onHandlePress(segment, index),
          isSelected: activeSegmentIndex === index,
          onLayout: event => segmentOnLayout(event, index),
          accessibilityState: {
            selected: activeSegmentIndex === index
          },
          accessibilityRole: "button",
          accessibilityLabel: segment,
          accessibilityHint: `${index + 1} on ${segments.length}`
        }, index);
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
      style: _style.default.flex,
      children: addonRight
    })]
  });
};
var _default = exports.default = SegmentedControls;
//# sourceMappingURL=index.native.js.map