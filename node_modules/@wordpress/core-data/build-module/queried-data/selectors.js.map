{"version":3,"names":["EquivalentKeyMap","createSelector","getQueryParts","setNestedValue","queriedItemsCacheByState","WeakMap","getQueriedItemsUncached","state","query","stableKey","page","perPage","include","fields","context","itemIds","queries","startOffset","endOffset","length","Math","min","items","i","itemId","Array","isArray","includes","undefined","hasOwnProperty","item","filteredItem","f","field","split","value","forEach","fieldName","itemIsComplete","push","getQueriedItems","queriedItemsCache","get","queriedItems","set","getQueriedTotalItems","_state$queries$contex","meta","totalItems","getQueriedTotalPages","_state$queries$contex2","totalPages"],"sources":["@wordpress/core-data/src/queried-data/selectors.js"],"sourcesContent":["/**\n * External dependencies\n */\nimport EquivalentKeyMap from 'equivalent-key-map';\n\n/**\n * WordPress dependencies\n */\nimport { createSelector } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport getQueryParts from './get-query-parts';\nimport { setNestedValue } from '../utils';\n\n/**\n * Cache of state keys to EquivalentKeyMap where the inner map tracks queries\n * to their resulting items set. WeakMap allows garbage collection on expired\n * state references.\n *\n * @type {WeakMap<Object,EquivalentKeyMap>}\n */\nconst queriedItemsCacheByState = new WeakMap();\n\n/**\n * Returns items for a given query, or null if the items are not known.\n *\n * @param {Object}  state State object.\n * @param {?Object} query Optional query.\n *\n * @return {?Array} Query items.\n */\nfunction getQueriedItemsUncached( state, query ) {\n\tconst { stableKey, page, perPage, include, fields, context } =\n\t\tgetQueryParts( query );\n\tlet itemIds;\n\n\tif ( state.queries?.[ context ]?.[ stableKey ] ) {\n\t\titemIds = state.queries[ context ][ stableKey ].itemIds;\n\t}\n\n\tif ( ! itemIds ) {\n\t\treturn null;\n\t}\n\n\tconst startOffset = perPage === -1 ? 0 : ( page - 1 ) * perPage;\n\tconst endOffset =\n\t\tperPage === -1\n\t\t\t? itemIds.length\n\t\t\t: Math.min( startOffset + perPage, itemIds.length );\n\n\tconst items = [];\n\tfor ( let i = startOffset; i < endOffset; i++ ) {\n\t\tconst itemId = itemIds[ i ];\n\t\tif ( Array.isArray( include ) && ! include.includes( itemId ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( itemId === undefined ) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Having a target item ID doesn't guarantee that this object has been queried.\n\t\tif ( ! state.items[ context ]?.hasOwnProperty( itemId ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = state.items[ context ][ itemId ];\n\n\t\tlet filteredItem;\n\t\tif ( Array.isArray( fields ) ) {\n\t\t\tfilteredItem = {};\n\n\t\t\tfor ( let f = 0; f < fields.length; f++ ) {\n\t\t\t\tconst field = fields[ f ].split( '.' );\n\t\t\t\tlet value = item;\n\t\t\t\tfield.forEach( ( fieldName ) => {\n\t\t\t\t\tvalue = value?.[ fieldName ];\n\t\t\t\t} );\n\n\t\t\t\tsetNestedValue( filteredItem, field, value );\n\t\t\t}\n\t\t} else {\n\t\t\t// If expecting a complete item, validate that completeness, or\n\t\t\t// otherwise abort.\n\t\t\tif ( ! state.itemIsComplete[ context ]?.[ itemId ] ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfilteredItem = item;\n\t\t}\n\n\t\titems.push( filteredItem );\n\t}\n\n\treturn items;\n}\n\n/**\n * Returns items for a given query, or null if the items are not known. Caches\n * result both per state (by reference) and per query (by deep equality).\n * The caching approach is intended to be durable to query objects which are\n * deeply but not referentially equal, since otherwise:\n *\n * `getQueriedItems( state, {} ) !== getQueriedItems( state, {} )`\n *\n * @param {Object}  state State object.\n * @param {?Object} query Optional query.\n *\n * @return {?Array} Query items.\n */\nexport const getQueriedItems = createSelector( ( state, query = {} ) => {\n\tlet queriedItemsCache = queriedItemsCacheByState.get( state );\n\tif ( queriedItemsCache ) {\n\t\tconst queriedItems = queriedItemsCache.get( query );\n\t\tif ( queriedItems !== undefined ) {\n\t\t\treturn queriedItems;\n\t\t}\n\t} else {\n\t\tqueriedItemsCache = new EquivalentKeyMap();\n\t\tqueriedItemsCacheByState.set( state, queriedItemsCache );\n\t}\n\n\tconst items = getQueriedItemsUncached( state, query );\n\tqueriedItemsCache.set( query, items );\n\treturn items;\n} );\n\nexport function getQueriedTotalItems( state, query = {} ) {\n\tconst { stableKey, context } = getQueryParts( query );\n\n\treturn state.queries?.[ context ]?.[ stableKey ]?.meta?.totalItems ?? null;\n}\n\nexport function getQueriedTotalPages( state, query = {} ) {\n\tconst { stableKey, context } = getQueryParts( query );\n\n\treturn state.queries?.[ context ]?.[ stableKey ]?.meta?.totalPages ?? null;\n}\n"],"mappings":"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","ignoreList":[]}