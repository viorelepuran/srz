{"version":3,"names":["_apiFetch","_interopRequireDefault","require","_url","CACHE","Map","fetchUrlData","url","options","endpoint","args","prependHTTP","isURL","Promise","reject","protocol","getProtocol","isValidProtocol","startsWith","test","has","get","apiFetch","path","addQueryArgs","then","res","set","_default","exports","default"],"sources":["@wordpress/core-data/src/fetch/__experimental-fetch-url-data.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport apiFetch from '@wordpress/api-fetch';\nimport {\n\taddQueryArgs,\n\tprependHTTP,\n\tisURL,\n\tgetProtocol,\n\tisValidProtocol,\n} from '@wordpress/url';\n\n/**\n * A simple in-memory cache for requests.\n * This avoids repeat HTTP requests which may be beneficial\n * for those wishing to preserve low-bandwidth.\n */\nconst CACHE = new Map();\n\n/**\n * @typedef WPRemoteUrlData\n *\n * @property {string} title contents of the remote URL's `<title>` tag.\n */\n\n/**\n * Fetches data about a remote URL.\n * eg: <title> tag, favicon...etc.\n *\n * @async\n * @param {string}  url     the URL to request details from.\n * @param {?Object} options any options to pass to the underlying fetch.\n * @example\n * ```js\n * import { __experimentalFetchUrlData as fetchUrlData } from '@wordpress/core-data';\n *\n * //...\n *\n * export function initialize( id, settings ) {\n *\n * settings.__experimentalFetchUrlData = (\n * url\n * ) => fetchUrlData( url );\n * ```\n * @return {Promise< WPRemoteUrlData[] >} Remote URL data.\n */\nconst fetchUrlData = async ( url, options = {} ) => {\n\tconst endpoint = '/wp-block-editor/v1/url-details';\n\n\tconst args = {\n\t\turl: prependHTTP( url ),\n\t};\n\n\tif ( ! isURL( url ) ) {\n\t\treturn Promise.reject( `${ url } is not a valid URL.` );\n\t}\n\n\t// Test for \"http\" based URL as it is possible for valid\n\t// yet unusable URLs such as `tel:123456` to be passed.\n\tconst protocol = getProtocol( url );\n\n\tif (\n\t\t! protocol ||\n\t\t! isValidProtocol( protocol ) ||\n\t\t! protocol.startsWith( 'http' ) ||\n\t\t! /^https?:\\/\\/[^\\/\\s]/i.test( url )\n\t) {\n\t\treturn Promise.reject(\n\t\t\t`${ url } does not have a valid protocol. URLs must be \"http\" based`\n\t\t);\n\t}\n\n\tif ( CACHE.has( url ) ) {\n\t\treturn CACHE.get( url );\n\t}\n\n\treturn apiFetch( {\n\t\tpath: addQueryArgs( endpoint, args ),\n\t\t...options,\n\t} ).then( ( res ) => {\n\t\tCACHE.set( url, res );\n\t\treturn res;\n\t} );\n};\n\nexport default fetchUrlData;\n"],"mappings":";;;;;;;AAGA,IAAAA,SAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,IAAA,GAAAD,OAAA;AAJA;AACA;AACA;;AAUA;AACA;AACA;AACA;AACA;AACA,MAAME,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAG,MAAAA,CAAQC,GAAG,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAM;EACnD,MAAMC,QAAQ,GAAG,iCAAiC;EAElD,MAAMC,IAAI,GAAG;IACZH,GAAG,EAAE,IAAAI,gBAAW,EAAEJ,GAAI;EACvB,CAAC;EAED,IAAK,CAAE,IAAAK,UAAK,EAAEL,GAAI,CAAC,EAAG;IACrB,OAAOM,OAAO,CAACC,MAAM,CAAE,GAAIP,GAAG,sBAAwB,CAAC;EACxD;;EAEA;EACA;EACA,MAAMQ,QAAQ,GAAG,IAAAC,gBAAW,EAAET,GAAI,CAAC;EAEnC,IACC,CAAEQ,QAAQ,IACV,CAAE,IAAAE,oBAAe,EAAEF,QAAS,CAAC,IAC7B,CAAEA,QAAQ,CAACG,UAAU,CAAE,MAAO,CAAC,IAC/B,CAAE,sBAAsB,CAACC,IAAI,CAAEZ,GAAI,CAAC,EACnC;IACD,OAAOM,OAAO,CAACC,MAAM,CACpB,GAAIP,GAAG,4DACR,CAAC;EACF;EAEA,IAAKH,KAAK,CAACgB,GAAG,CAAEb,GAAI,CAAC,EAAG;IACvB,OAAOH,KAAK,CAACiB,GAAG,CAAEd,GAAI,CAAC;EACxB;EAEA,OAAO,IAAAe,iBAAQ,EAAE;IAChBC,IAAI,EAAE,IAAAC,iBAAY,EAAEf,QAAQ,EAAEC,IAAK,CAAC;IACpC,GAAGF;EACJ,CAAE,CAAC,CAACiB,IAAI,CAAIC,GAAG,IAAM;IACpBtB,KAAK,CAACuB,GAAG,CAAEpB,GAAG,EAAEmB,GAAI,CAAC;IACrB,OAAOA,GAAG;EACX,CAAE,CAAC;AACJ,CAAC;AAAC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEaxB,YAAY","ignoreList":[]}