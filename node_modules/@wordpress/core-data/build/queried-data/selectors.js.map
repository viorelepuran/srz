{"version":3,"names":["_equivalentKeyMap","_interopRequireDefault","require","_data","_getQueryParts","_utils","queriedItemsCacheByState","WeakMap","getQueriedItemsUncached","state","query","stableKey","page","perPage","include","fields","context","getQueryParts","itemIds","queries","startOffset","endOffset","length","Math","min","items","i","itemId","Array","isArray","includes","undefined","hasOwnProperty","item","filteredItem","f","field","split","value","forEach","fieldName","setNestedValue","itemIsComplete","push","getQueriedItems","exports","createSelector","queriedItemsCache","get","queriedItems","EquivalentKeyMap","set","getQueriedTotalItems","_state$queries$contex","meta","totalItems","getQueriedTotalPages","_state$queries$contex2","totalPages"],"sources":["@wordpress/core-data/src/queried-data/selectors.js"],"sourcesContent":["/**\n * External dependencies\n */\nimport EquivalentKeyMap from 'equivalent-key-map';\n\n/**\n * WordPress dependencies\n */\nimport { createSelector } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport getQueryParts from './get-query-parts';\nimport { setNestedValue } from '../utils';\n\n/**\n * Cache of state keys to EquivalentKeyMap where the inner map tracks queries\n * to their resulting items set. WeakMap allows garbage collection on expired\n * state references.\n *\n * @type {WeakMap<Object,EquivalentKeyMap>}\n */\nconst queriedItemsCacheByState = new WeakMap();\n\n/**\n * Returns items for a given query, or null if the items are not known.\n *\n * @param {Object}  state State object.\n * @param {?Object} query Optional query.\n *\n * @return {?Array} Query items.\n */\nfunction getQueriedItemsUncached( state, query ) {\n\tconst { stableKey, page, perPage, include, fields, context } =\n\t\tgetQueryParts( query );\n\tlet itemIds;\n\n\tif ( state.queries?.[ context ]?.[ stableKey ] ) {\n\t\titemIds = state.queries[ context ][ stableKey ].itemIds;\n\t}\n\n\tif ( ! itemIds ) {\n\t\treturn null;\n\t}\n\n\tconst startOffset = perPage === -1 ? 0 : ( page - 1 ) * perPage;\n\tconst endOffset =\n\t\tperPage === -1\n\t\t\t? itemIds.length\n\t\t\t: Math.min( startOffset + perPage, itemIds.length );\n\n\tconst items = [];\n\tfor ( let i = startOffset; i < endOffset; i++ ) {\n\t\tconst itemId = itemIds[ i ];\n\t\tif ( Array.isArray( include ) && ! include.includes( itemId ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( itemId === undefined ) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Having a target item ID doesn't guarantee that this object has been queried.\n\t\tif ( ! state.items[ context ]?.hasOwnProperty( itemId ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = state.items[ context ][ itemId ];\n\n\t\tlet filteredItem;\n\t\tif ( Array.isArray( fields ) ) {\n\t\t\tfilteredItem = {};\n\n\t\t\tfor ( let f = 0; f < fields.length; f++ ) {\n\t\t\t\tconst field = fields[ f ].split( '.' );\n\t\t\t\tlet value = item;\n\t\t\t\tfield.forEach( ( fieldName ) => {\n\t\t\t\t\tvalue = value?.[ fieldName ];\n\t\t\t\t} );\n\n\t\t\t\tsetNestedValue( filteredItem, field, value );\n\t\t\t}\n\t\t} else {\n\t\t\t// If expecting a complete item, validate that completeness, or\n\t\t\t// otherwise abort.\n\t\t\tif ( ! state.itemIsComplete[ context ]?.[ itemId ] ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfilteredItem = item;\n\t\t}\n\n\t\titems.push( filteredItem );\n\t}\n\n\treturn items;\n}\n\n/**\n * Returns items for a given query, or null if the items are not known. Caches\n * result both per state (by reference) and per query (by deep equality).\n * The caching approach is intended to be durable to query objects which are\n * deeply but not referentially equal, since otherwise:\n *\n * `getQueriedItems( state, {} ) !== getQueriedItems( state, {} )`\n *\n * @param {Object}  state State object.\n * @param {?Object} query Optional query.\n *\n * @return {?Array} Query items.\n */\nexport const getQueriedItems = createSelector( ( state, query = {} ) => {\n\tlet queriedItemsCache = queriedItemsCacheByState.get( state );\n\tif ( queriedItemsCache ) {\n\t\tconst queriedItems = queriedItemsCache.get( query );\n\t\tif ( queriedItems !== undefined ) {\n\t\t\treturn queriedItems;\n\t\t}\n\t} else {\n\t\tqueriedItemsCache = new EquivalentKeyMap();\n\t\tqueriedItemsCacheByState.set( state, queriedItemsCache );\n\t}\n\n\tconst items = getQueriedItemsUncached( state, query );\n\tqueriedItemsCache.set( query, items );\n\treturn items;\n} );\n\nexport function getQueriedTotalItems( state, query = {} ) {\n\tconst { stableKey, context } = getQueryParts( query );\n\n\treturn state.queries?.[ context ]?.[ stableKey ]?.meta?.totalItems ?? null;\n}\n\nexport function getQueriedTotalPages( state, query = {} ) {\n\tconst { stableKey, context } = getQueryParts( query );\n\n\treturn state.queries?.[ context ]?.[ stableKey ]?.meta?.totalPages ?? null;\n}\n"],"mappings":"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","ignoreList":[]}