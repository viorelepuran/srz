"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editPostWithNotices = exports.deletePostWithNotices = void 0;
var _notices = require("@wordpress/notices");
var _coreData = require("@wordpress/core-data");
var _data = require("@wordpress/data");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function getErrorMessagesFromPromises(allSettledResults) {
  const errorMessages = new Set();
  // If there was at lease one failure.
  if (allSettledResults.length === 1) {
    const typedError = allSettledResults[0];
    if (typedError.reason?.message) {
      errorMessages.add(typedError.reason.message);
    }
  } else {
    const failedPromises = allSettledResults.filter(({
      status
    }) => status === 'rejected');
    for (const failedPromise of failedPromises) {
      const typedError = failedPromise;
      if (typedError.reason?.message) {
        errorMessages.add(typedError.reason.message);
      }
    }
  }
  return errorMessages;
}
const deletePostWithNotices = async (posts, notice, callbacks) => {
  const {
    createSuccessNotice,
    createErrorNotice
  } = (0, _data.dispatch)(_notices.store);
  const {
    deleteEntityRecord
  } = (0, _data.dispatch)(_coreData.store);
  const allSettledResults = await Promise.allSettled(posts.map(post => {
    return deleteEntityRecord('postType', post.type, post.id, {
      force: true
    }, {
      throwOnError: true
    });
  }));
  // If all the promises were fulfilled with success.
  if (allSettledResults.every(({
    status
  }) => status === 'fulfilled')) {
    var _notice$success$type;
    let successMessage;
    if (allSettledResults.length === 1) {
      successMessage = notice.success.messages.getMessage(posts[0]);
    } else {
      successMessage = notice.success.messages.getBatchMessage(posts);
    }
    createSuccessNotice(successMessage, {
      type: (_notice$success$type = notice.success.type) !== null && _notice$success$type !== void 0 ? _notice$success$type : 'snackbar',
      id: notice.success.id
    });
    callbacks.onActionPerformed?.(posts);
  } else {
    var _notice$error$type;
    const errorMessages = getErrorMessagesFromPromises(allSettledResults);
    let errorMessage = '';
    if (allSettledResults.length === 1) {
      errorMessage = notice.error.messages.getMessage(errorMessages);
    } else {
      errorMessage = notice.error.messages.getBatchMessage(errorMessages);
    }
    createErrorNotice(errorMessage, {
      type: (_notice$error$type = notice.error.type) !== null && _notice$error$type !== void 0 ? _notice$error$type : 'snackbar',
      id: notice.error.id
    });
    callbacks.onActionError?.();
  }
};
exports.deletePostWithNotices = deletePostWithNotices;
const editPostWithNotices = async (postsWithUpdates, notice, callbacks) => {
  const {
    createSuccessNotice,
    createErrorNotice
  } = (0, _data.dispatch)(_notices.store);
  const {
    editEntityRecord,
    saveEditedEntityRecord
  } = (0, _data.dispatch)(_coreData.store);
  await Promise.allSettled(postsWithUpdates.map(post => {
    return editEntityRecord('postType', post.originalPost.type, post.originalPost.id, {
      ...post.changes
    });
  }));
  const allSettledResults = await Promise.allSettled(postsWithUpdates.map(post => {
    return saveEditedEntityRecord('postType', post.originalPost.type, post.originalPost.id, {
      throwOnError: true
    });
  }));
  // If all the promises were fulfilled with success.
  if (allSettledResults.every(({
    status
  }) => status === 'fulfilled')) {
    var _notice$success$type2;
    let successMessage;
    if (allSettledResults.length === 1) {
      successMessage = notice.success.messages.getMessage(postsWithUpdates[0].originalPost);
    } else {
      successMessage = notice.success.messages.getBatchMessage(postsWithUpdates.map(post => post.originalPost));
    }
    createSuccessNotice(successMessage, {
      type: (_notice$success$type2 = notice.success.type) !== null && _notice$success$type2 !== void 0 ? _notice$success$type2 : 'snackbar',
      id: notice.success.id
    });
    callbacks.onActionPerformed?.(postsWithUpdates.map(post => post.originalPost));
  } else {
    var _notice$error$type2;
    const errorMessages = getErrorMessagesFromPromises(allSettledResults);
    let errorMessage = '';
    if (allSettledResults.length === 1) {
      errorMessage = notice.error.messages.getMessage(errorMessages);
    } else {
      errorMessage = notice.error.messages.getBatchMessage(errorMessages);
    }
    createErrorNotice(errorMessage, {
      type: (_notice$error$type2 = notice.error.type) !== null && _notice$error$type2 !== void 0 ? _notice$error$type2 : 'snackbar',
      id: notice.error.id
    });
    callbacks.onActionError?.();
  }
};
exports.editPostWithNotices = editPostWithNotices;
//# sourceMappingURL=index.js.map