"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PageAttributesParent = PageAttributesParent;
exports.getItemPriority = exports.ParentEdit = void 0;
var _removeAccents = _interopRequireDefault(require("remove-accents"));
var _components = require("@wordpress/components");
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _coreData = require("@wordpress/core-data");
var _compose = require("@wordpress/compose");
var _htmlEntities = require("@wordpress/html-entities");
var _i18n = require("@wordpress/i18n");
var _url = require("@wordpress/url");
var _utils = require("./utils");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

// @ts-ignore

/**
 * Internal dependencies
 */

function buildTermsTree(flatTerms) {
  const flatTermsWithParentAndChildren = flatTerms.map(term => {
    return {
      children: [],
      ...term
    };
  });

  // All terms should have a `parent` because we're about to index them by it.
  if (flatTermsWithParentAndChildren.some(({
    parent
  }) => parent === null || parent === undefined)) {
    return flatTermsWithParentAndChildren;
  }
  const termsByParent = flatTermsWithParentAndChildren.reduce((acc, term) => {
    const {
      parent
    } = term;
    if (!acc[parent]) {
      acc[parent] = [];
    }
    acc[parent].push(term);
    return acc;
  }, {});
  const fillWithChildren = terms => {
    return terms.map(term => {
      const children = termsByParent[term.id];
      return {
        ...term,
        children: children && children.length ? fillWithChildren(children) : []
      };
    });
  };
  return fillWithChildren(termsByParent['0'] || []);
}
const getItemPriority = (name, searchValue) => {
  const normalizedName = (0, _removeAccents.default)(name || '').toLowerCase();
  const normalizedSearch = (0, _removeAccents.default)(searchValue || '').toLowerCase();
  if (normalizedName === normalizedSearch) {
    return 0;
  }
  if (normalizedName.startsWith(normalizedSearch)) {
    return normalizedName.length;
  }
  return Infinity;
};
exports.getItemPriority = getItemPriority;
function PageAttributesParent({
  data,
  onChangeControl
}) {
  const [fieldValue, setFieldValue] = (0, _element.useState)(null);
  const pageId = data.parent;
  const postId = data.id;
  const postTypeSlug = data.type;
  const {
    parentPostTitle,
    pageItems,
    isHierarchical
  } = (0, _data.useSelect)(select => {
    const {
      getEntityRecord,
      getEntityRecords,
      getPostType
    } = select(_coreData.store);
    const postTypeInfo = getPostType(postTypeSlug);
    const postIsHierarchical = postTypeInfo?.hierarchical && postTypeInfo.viewable;
    const parentPost = pageId ? getEntityRecord('postType', postTypeSlug, pageId) : null;
    const query = {
      per_page: 100,
      exclude: postId,
      parent_exclude: postId,
      orderby: 'menu_order',
      order: 'asc',
      _fields: 'id,title,parent',
      ...(fieldValue !== null && {
        search: fieldValue
      })
    };
    return {
      isHierarchical: postIsHierarchical,
      parentPostTitle: parentPost ? (0, _utils.getTitleWithFallbackName)(parentPost) : '',
      pageItems: postIsHierarchical ? getEntityRecords('postType', postTypeSlug, query) : null
    };
  }, [fieldValue, pageId, postId, postTypeSlug]);

  /**
   * This logic has been copied from https://github.com/WordPress/gutenberg/blob/0249771b519d5646171fb9fae422006c8ab773f2/packages/editor/src/components/page-attributes/parent.js#L106.
   */
  const parentOptions = (0, _element.useMemo)(() => {
    const getOptionsFromTree = (tree, level = 0) => {
      const mappedNodes = tree.map(treeNode => [{
        value: treeNode.id,
        label: 'â€” '.repeat(level) + (0, _htmlEntities.decodeEntities)(treeNode.name),
        rawName: treeNode.name
      }, ...getOptionsFromTree(treeNode.children || [], level + 1)]);
      const sortedNodes = mappedNodes.sort(([a], [b]) => {
        const priorityA = getItemPriority(a.rawName, fieldValue !== null && fieldValue !== void 0 ? fieldValue : '');
        const priorityB = getItemPriority(b.rawName, fieldValue !== null && fieldValue !== void 0 ? fieldValue : '');
        return priorityA >= priorityB ? 1 : -1;
      });
      return sortedNodes.flat();
    };
    if (!pageItems) {
      return [];
    }
    let tree = pageItems.map(item => {
      var _item$parent;
      return {
        id: item.id,
        parent: (_item$parent = item.parent) !== null && _item$parent !== void 0 ? _item$parent : null,
        name: (0, _utils.getTitleWithFallbackName)(item)
      };
    });

    // Only build a hierarchical tree when not searching.
    if (!fieldValue) {
      tree = buildTermsTree(tree);
    }
    const opts = getOptionsFromTree(tree);

    // Ensure the current parent is in the options list.
    const optsHasParent = opts.find(item => item.value === pageId);
    if (pageId && parentPostTitle && !optsHasParent) {
      opts.unshift({
        value: pageId,
        label: parentPostTitle,
        rawName: ''
      });
    }
    return opts.map(option => ({
      ...option,
      value: option.value.toString()
    }));
  }, [pageItems, fieldValue, parentPostTitle, pageId]);
  if (!isHierarchical) {
    return null;
  }

  /**
   * Handle user input.
   *
   * @param {string} inputValue The current value of the input field.
   */
  const handleKeydown = inputValue => {
    setFieldValue(inputValue);
  };

  /**
   * Handle author selection.
   *
   * @param {Object} selectedPostId The selected Author.
   */
  const handleChange = selectedPostId => {
    if (selectedPostId) {
      var _parseInt;
      return onChangeControl((_parseInt = parseInt(selectedPostId, 10)) !== null && _parseInt !== void 0 ? _parseInt : 0);
    }
    onChangeControl(0);
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ComboboxControl, {
    __nextHasNoMarginBottom: true,
    __next40pxDefaultSize: true,
    label: (0, _i18n.__)('Parent'),
    help: (0, _i18n.__)('Choose a parent page.'),
    value: pageId?.toString(),
    options: parentOptions,
    onFilterValueChange: (0, _compose.debounce)(value => handleKeydown(value), 300),
    onChange: handleChange,
    hideLabelFromVision: true
  });
}
const ParentEdit = ({
  data,
  field,
  onChange
}) => {
  const {
    id
  } = field;
  const homeUrl = (0, _data.useSelect)(select => {
    return select(_coreData.store).getEntityRecord('root', '__unstableBase')?.home;
  }, []);
  const onChangeControl = (0, _element.useCallback)(newValue => onChange({
    [id]: newValue
  }), [id, onChange]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("fieldset", {
    className: "fields-controls__parent",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [(0, _element.createInterpolateElement)((0, _i18n.sprintf)(/* translators: %1$s The home URL of the WordPress installation without the scheme. */
      (0, _i18n.__)('Child pages inherit characteristics from their parent, such as URL structure. For instance, if "Pricing" is a child of "Services", its URL would be %1$s<wbr />/services<wbr />/pricing.'), (0, _url.filterURLForDisplay)(homeUrl).replace(/([/.])/g, '<wbr />$1')), {
        wbr: /*#__PURE__*/(0, _jsxRuntime.jsx)("wbr", {})
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        children: (0, _element.createInterpolateElement)((0, _i18n.__)('They also show up as sub-items in the default navigation menu. <a>Learn more.</a>'), {
          a: /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ExternalLink, {
            href: (0, _i18n.__)('https://wordpress.org/documentation/article/page-post-settings-sidebar/#page-attributes'),
            children: undefined
          })
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(PageAttributesParent, {
        data: data,
        onChangeControl: onChangeControl
      })]
    })
  });
};
exports.ParentEdit = ParentEdit;
//# sourceMappingURL=parent-edit.js.map