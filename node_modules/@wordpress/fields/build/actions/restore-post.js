"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _icons = require("@wordpress/icons");
var _coreData = require("@wordpress/core-data");
var _i18n = require("@wordpress/i18n");
var _notices = require("@wordpress/notices");
var _utils = require("./utils");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const restorePost = {
  id: 'restore',
  label: (0, _i18n.__)('Restore'),
  isPrimary: true,
  icon: _icons.backup,
  supportsBulk: true,
  isEligible(item) {
    return !(0, _utils.isTemplateOrTemplatePart)(item) && item.type !== 'wp_block' && item.status === 'trash' && item.permissions?.update;
  },
  async callback(posts, {
    registry,
    onActionPerformed
  }) {
    const {
      createSuccessNotice,
      createErrorNotice
    } = registry.dispatch(_notices.store);
    const {
      editEntityRecord,
      saveEditedEntityRecord
    } = registry.dispatch(_coreData.store);
    await Promise.allSettled(posts.map(post => {
      return editEntityRecord('postType', post.type, post.id, {
        status: 'draft'
      });
    }));
    const promiseResult = await Promise.allSettled(posts.map(post => {
      return saveEditedEntityRecord('postType', post.type, post.id, {
        throwOnError: true
      });
    }));
    if (promiseResult.every(({
      status
    }) => status === 'fulfilled')) {
      let successMessage;
      if (posts.length === 1) {
        successMessage = (0, _i18n.sprintf)(/* translators: The number of posts. */
        (0, _i18n.__)('"%s" has been restored.'), (0, _utils.getItemTitle)(posts[0]));
      } else if (posts[0].type === 'page') {
        successMessage = (0, _i18n.sprintf)(/* translators: The number of posts. */
        (0, _i18n.__)('%d pages have been restored.'), posts.length);
      } else {
        successMessage = (0, _i18n.sprintf)(/* translators: The number of posts. */
        (0, _i18n.__)('%d posts have been restored.'), posts.length);
      }
      createSuccessNotice(successMessage, {
        type: 'snackbar',
        id: 'restore-post-action'
      });
      if (onActionPerformed) {
        onActionPerformed(posts);
      }
    } else {
      // If there was at lease one failure.
      let errorMessage;
      // If we were trying to move a single post to the trash.
      if (promiseResult.length === 1) {
        const typedError = promiseResult[0];
        if (typedError.reason?.message) {
          errorMessage = typedError.reason.message;
        } else {
          errorMessage = (0, _i18n.__)('An error occurred while restoring the post.');
        }
        // If we were trying to move multiple posts to the trash
      } else {
        const errorMessages = new Set();
        const failedPromises = promiseResult.filter(({
          status
        }) => status === 'rejected');
        for (const failedPromise of failedPromises) {
          const typedError = failedPromise;
          if (typedError.reason?.message) {
            errorMessages.add(typedError.reason.message);
          }
        }
        if (errorMessages.size === 0) {
          errorMessage = (0, _i18n.__)('An error occurred while restoring the posts.');
        } else if (errorMessages.size === 1) {
          errorMessage = (0, _i18n.sprintf)(/* translators: %s: an error message */
          (0, _i18n.__)('An error occurred while restoring the posts: %s'), [...errorMessages][0]);
        } else {
          errorMessage = (0, _i18n.sprintf)(/* translators: %s: a list of comma separated error messages */
          (0, _i18n.__)('Some errors occurred while restoring the posts: %s'), [...errorMessages].join(','));
        }
      }
      createErrorNotice(errorMessage, {
        type: 'snackbar'
      });
    }
  }
};

/**
 * Restore action for PostWithPermissions.
 */
var _default = exports.default = restorePost;
//# sourceMappingURL=restore-post.js.map