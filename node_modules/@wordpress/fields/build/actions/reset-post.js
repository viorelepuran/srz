"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _icons = require("@wordpress/icons");
var _data = require("@wordpress/data");
var _coreData = require("@wordpress/core-data");
var _i18n = require("@wordpress/i18n");
var _notices = require("@wordpress/notices");
var _element = require("@wordpress/element");
var _blocks = require("@wordpress/blocks");
var _components = require("@wordpress/components");
var _url = require("@wordpress/url");
var _apiFetch = _interopRequireDefault(require("@wordpress/api-fetch"));
var _utils = require("./utils");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

// @ts-ignore

/**
 * Internal dependencies
 */

const isTemplateRevertable = templateOrTemplatePart => {
  if (!templateOrTemplatePart) {
    return false;
  }
  return templateOrTemplatePart.source === 'custom' && (Boolean(templateOrTemplatePart?.plugin) || templateOrTemplatePart?.has_theme_file);
};

/**
 *  Copied - pasted from https://github.com/WordPress/gutenberg/blob/bf1462ad37d4637ebbf63270b9c244b23c69e2a8/packages/editor/src/store/private-actions.js#L233-L365
 *
 * @param {Object}  template            The template to revert.
 * @param {Object}  [options]
 * @param {boolean} [options.allowUndo] Whether to allow the user to undo
 *                                      reverting the template. Default true.
 */
const revertTemplate = async (template, {
  allowUndo = true
} = {}) => {
  const noticeId = 'edit-site-template-reverted';
  (0, _data.dispatch)(_notices.store).removeNotice(noticeId);
  if (!isTemplateRevertable(template)) {
    (0, _data.dispatch)(_notices.store).createErrorNotice((0, _i18n.__)('This template is not revertable.'), {
      type: 'snackbar'
    });
    return;
  }
  try {
    const templateEntityConfig = (0, _data.select)(_coreData.store).getEntityConfig('postType', template.type);
    if (!templateEntityConfig) {
      (0, _data.dispatch)(_notices.store).createErrorNotice((0, _i18n.__)('The editor has encountered an unexpected error. Please reload.'), {
        type: 'snackbar'
      });
      return;
    }
    const fileTemplatePath = (0, _url.addQueryArgs)(`${templateEntityConfig.baseURL}/${template.id}`, {
      context: 'edit',
      source: template.origin
    });
    const fileTemplate = await (0, _apiFetch.default)({
      path: fileTemplatePath
    });
    if (!fileTemplate) {
      (0, _data.dispatch)(_notices.store).createErrorNotice((0, _i18n.__)('The editor has encountered an unexpected error. Please reload.'), {
        type: 'snackbar'
      });
      return;
    }
    const serializeBlocks = ({
      blocks: blocksForSerialization = []
    }) => (0, _blocks.__unstableSerializeAndClean)(blocksForSerialization);
    const edited = (0, _data.select)(_coreData.store).getEditedEntityRecord('postType', template.type, template.id);

    // We are fixing up the undo level here to make sure we can undo
    // the revert in the header toolbar correctly.
    (0, _data.dispatch)(_coreData.store).editEntityRecord('postType', template.type, template.id, {
      content: serializeBlocks,
      // Required to make the `undo` behave correctly.
      blocks: edited.blocks,
      // Required to revert the blocks in the editor.
      source: 'custom' // required to avoid turning the editor into a dirty state
    }, {
      undoIgnore: true // Required to merge this edit with the last undo level.
    });
    const blocks = (0, _blocks.parse)(fileTemplate?.content?.raw);
    (0, _data.dispatch)(_coreData.store).editEntityRecord('postType', template.type, fileTemplate.id, {
      content: serializeBlocks,
      blocks,
      source: 'theme'
    });
    if (allowUndo) {
      const undoRevert = () => {
        (0, _data.dispatch)(_coreData.store).editEntityRecord('postType', template.type, edited.id, {
          content: serializeBlocks,
          blocks: edited.blocks,
          source: 'custom'
        });
      };
      (0, _data.dispatch)(_notices.store).createSuccessNotice((0, _i18n.__)('Template reset.'), {
        type: 'snackbar',
        id: noticeId,
        actions: [{
          label: (0, _i18n.__)('Undo'),
          onClick: undoRevert
        }]
      });
    }
  } catch (error) {
    const errorMessage = error.message && error.code !== 'unknown_error' ? error.message : (0, _i18n.__)('Template revert failed. Please reload.');
    (0, _data.dispatch)(_notices.store).createErrorNotice(errorMessage, {
      type: 'snackbar'
    });
  }
};
const resetPostAction = {
  id: 'reset-post',
  label: (0, _i18n.__)('Reset'),
  isEligible: item => {
    return (0, _utils.isTemplateOrTemplatePart)(item) && item?.source === 'custom' && (Boolean(item.type === 'wp_template' && item?.plugin) || item?.has_theme_file);
  },
  icon: _icons.backup,
  supportsBulk: true,
  hideModalHeader: true,
  modalFocusOnMount: 'firstContentElement',
  RenderModal: ({
    items,
    closeModal,
    onActionPerformed
  }) => {
    const [isBusy, setIsBusy] = (0, _element.useState)(false);
    const {
      saveEditedEntityRecord
    } = (0, _data.useDispatch)(_coreData.store);
    const {
      createSuccessNotice,
      createErrorNotice
    } = (0, _data.useDispatch)(_notices.store);
    const onConfirm = async () => {
      try {
        for (const template of items) {
          await revertTemplate(template, {
            allowUndo: false
          });
          await saveEditedEntityRecord('postType', template.type, template.id);
        }
        createSuccessNotice(items.length > 1 ? (0, _i18n.sprintf)(/* translators: The number of items. */
        (0, _i18n.__)('%s items reset.'), items.length) : (0, _i18n.sprintf)(/* translators: The template/part's name. */
        (0, _i18n.__)('"%s" reset.'), (0, _utils.getItemTitle)(items[0])), {
          type: 'snackbar',
          id: 'revert-template-action'
        });
      } catch (error) {
        let fallbackErrorMessage;
        if (items[0].type === 'wp_template') {
          fallbackErrorMessage = items.length === 1 ? (0, _i18n.__)('An error occurred while reverting the template.') : (0, _i18n.__)('An error occurred while reverting the templates.');
        } else {
          fallbackErrorMessage = items.length === 1 ? (0, _i18n.__)('An error occurred while reverting the template part.') : (0, _i18n.__)('An error occurred while reverting the template parts.');
        }
        const typedError = error;
        const errorMessage = typedError.message && typedError.code !== 'unknown_error' ? typedError.message : fallbackErrorMessage;
        createErrorNotice(errorMessage, {
          type: 'snackbar'
        });
      }
    };
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalVStack, {
      spacing: "5",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalText, {
        children: (0, _i18n.__)('Reset to default and clear all customizations?')
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalHStack, {
        justify: "right",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Button, {
          __next40pxDefaultSize: true,
          variant: "tertiary",
          onClick: closeModal,
          disabled: isBusy,
          accessibleWhenDisabled: true,
          children: (0, _i18n.__)('Cancel')
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Button, {
          __next40pxDefaultSize: true,
          variant: "primary",
          onClick: async () => {
            setIsBusy(true);
            await onConfirm();
            onActionPerformed?.(items);
            setIsBusy(false);
            closeModal?.();
          },
          isBusy: isBusy,
          disabled: isBusy,
          accessibleWhenDisabled: true,
          children: (0, _i18n.__)('Reset')
        })]
      })]
    });
  }
};

/**
 * Reset action for Template and TemplatePart.
 */
var _default = exports.default = resetPostAction;
//# sourceMappingURL=reset-post.js.map