/**
 * External dependencies
 */
import removeAccents from 'remove-accents';

/**
 * WordPress dependencies
 */
import { ComboboxControl, ExternalLink } from '@wordpress/components';
import { useSelect } from '@wordpress/data';
import { createInterpolateElement, useCallback, useMemo, useState } from '@wordpress/element';
// @ts-ignore
import { store as coreStore } from '@wordpress/core-data';
import { debounce } from '@wordpress/compose';
import { decodeEntities } from '@wordpress/html-entities';
import { __, sprintf } from '@wordpress/i18n';
import { filterURLForDisplay } from '@wordpress/url';

/**
 * Internal dependencies
 */

import { getTitleWithFallbackName } from './utils';
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
function buildTermsTree(flatTerms) {
  const flatTermsWithParentAndChildren = flatTerms.map(term => {
    return {
      children: [],
      ...term
    };
  });

  // All terms should have a `parent` because we're about to index them by it.
  if (flatTermsWithParentAndChildren.some(({
    parent
  }) => parent === null || parent === undefined)) {
    return flatTermsWithParentAndChildren;
  }
  const termsByParent = flatTermsWithParentAndChildren.reduce((acc, term) => {
    const {
      parent
    } = term;
    if (!acc[parent]) {
      acc[parent] = [];
    }
    acc[parent].push(term);
    return acc;
  }, {});
  const fillWithChildren = terms => {
    return terms.map(term => {
      const children = termsByParent[term.id];
      return {
        ...term,
        children: children && children.length ? fillWithChildren(children) : []
      };
    });
  };
  return fillWithChildren(termsByParent['0'] || []);
}
export const getItemPriority = (name, searchValue) => {
  const normalizedName = removeAccents(name || '').toLowerCase();
  const normalizedSearch = removeAccents(searchValue || '').toLowerCase();
  if (normalizedName === normalizedSearch) {
    return 0;
  }
  if (normalizedName.startsWith(normalizedSearch)) {
    return normalizedName.length;
  }
  return Infinity;
};
export function PageAttributesParent({
  data,
  onChangeControl
}) {
  const [fieldValue, setFieldValue] = useState(null);
  const pageId = data.parent;
  const postId = data.id;
  const postTypeSlug = data.type;
  const {
    parentPostTitle,
    pageItems,
    isHierarchical
  } = useSelect(select => {
    const {
      getEntityRecord,
      getEntityRecords,
      getPostType
    } = select(coreStore);
    const postTypeInfo = getPostType(postTypeSlug);
    const postIsHierarchical = postTypeInfo?.hierarchical && postTypeInfo.viewable;
    const parentPost = pageId ? getEntityRecord('postType', postTypeSlug, pageId) : null;
    const query = {
      per_page: 100,
      exclude: postId,
      parent_exclude: postId,
      orderby: 'menu_order',
      order: 'asc',
      _fields: 'id,title,parent',
      ...(fieldValue !== null && {
        search: fieldValue
      })
    };
    return {
      isHierarchical: postIsHierarchical,
      parentPostTitle: parentPost ? getTitleWithFallbackName(parentPost) : '',
      pageItems: postIsHierarchical ? getEntityRecords('postType', postTypeSlug, query) : null
    };
  }, [fieldValue, pageId, postId, postTypeSlug]);

  /**
   * This logic has been copied from https://github.com/WordPress/gutenberg/blob/0249771b519d5646171fb9fae422006c8ab773f2/packages/editor/src/components/page-attributes/parent.js#L106.
   */
  const parentOptions = useMemo(() => {
    const getOptionsFromTree = (tree, level = 0) => {
      const mappedNodes = tree.map(treeNode => [{
        value: treeNode.id,
        label: 'â€” '.repeat(level) + decodeEntities(treeNode.name),
        rawName: treeNode.name
      }, ...getOptionsFromTree(treeNode.children || [], level + 1)]);
      const sortedNodes = mappedNodes.sort(([a], [b]) => {
        const priorityA = getItemPriority(a.rawName, fieldValue !== null && fieldValue !== void 0 ? fieldValue : '');
        const priorityB = getItemPriority(b.rawName, fieldValue !== null && fieldValue !== void 0 ? fieldValue : '');
        return priorityA >= priorityB ? 1 : -1;
      });
      return sortedNodes.flat();
    };
    if (!pageItems) {
      return [];
    }
    let tree = pageItems.map(item => {
      var _item$parent;
      return {
        id: item.id,
        parent: (_item$parent = item.parent) !== null && _item$parent !== void 0 ? _item$parent : null,
        name: getTitleWithFallbackName(item)
      };
    });

    // Only build a hierarchical tree when not searching.
    if (!fieldValue) {
      tree = buildTermsTree(tree);
    }
    const opts = getOptionsFromTree(tree);

    // Ensure the current parent is in the options list.
    const optsHasParent = opts.find(item => item.value === pageId);
    if (pageId && parentPostTitle && !optsHasParent) {
      opts.unshift({
        value: pageId,
        label: parentPostTitle,
        rawName: ''
      });
    }
    return opts.map(option => ({
      ...option,
      value: option.value.toString()
    }));
  }, [pageItems, fieldValue, parentPostTitle, pageId]);
  if (!isHierarchical) {
    return null;
  }

  /**
   * Handle user input.
   *
   * @param {string} inputValue The current value of the input field.
   */
  const handleKeydown = inputValue => {
    setFieldValue(inputValue);
  };

  /**
   * Handle author selection.
   *
   * @param {Object} selectedPostId The selected Author.
   */
  const handleChange = selectedPostId => {
    if (selectedPostId) {
      var _parseInt;
      return onChangeControl((_parseInt = parseInt(selectedPostId, 10)) !== null && _parseInt !== void 0 ? _parseInt : 0);
    }
    onChangeControl(0);
  };
  return /*#__PURE__*/_jsx(ComboboxControl, {
    __nextHasNoMarginBottom: true,
    __next40pxDefaultSize: true,
    label: __('Parent'),
    help: __('Choose a parent page.'),
    value: pageId?.toString(),
    options: parentOptions,
    onFilterValueChange: debounce(value => handleKeydown(value), 300),
    onChange: handleChange,
    hideLabelFromVision: true
  });
}
export const ParentEdit = ({
  data,
  field,
  onChange
}) => {
  const {
    id
  } = field;
  const homeUrl = useSelect(select => {
    return select(coreStore).getEntityRecord('root', '__unstableBase')?.home;
  }, []);
  const onChangeControl = useCallback(newValue => onChange({
    [id]: newValue
  }), [id, onChange]);
  return /*#__PURE__*/_jsx("fieldset", {
    className: "fields-controls__parent",
    children: /*#__PURE__*/_jsxs("div", {
      children: [createInterpolateElement(sprintf(/* translators: %1$s The home URL of the WordPress installation without the scheme. */
      __('Child pages inherit characteristics from their parent, such as URL structure. For instance, if "Pricing" is a child of "Services", its URL would be %1$s<wbr />/services<wbr />/pricing.'), filterURLForDisplay(homeUrl).replace(/([/.])/g, '<wbr />$1')), {
        wbr: /*#__PURE__*/_jsx("wbr", {})
      }), /*#__PURE__*/_jsx("p", {
        children: createInterpolateElement(__('They also show up as sub-items in the default navigation menu. <a>Learn more.</a>'), {
          a: /*#__PURE__*/_jsx(ExternalLink, {
            href: __('https://wordpress.org/documentation/article/page-post-settings-sidebar/#page-attributes'),
            children: undefined
          })
        })
      }), /*#__PURE__*/_jsx(PageAttributesParent, {
        data: data,
        onChangeControl: onChangeControl
      })]
    })
  });
};
//# sourceMappingURL=parent-edit.js.map