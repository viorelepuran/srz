"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateHead = exports.headElements = exports.fetchHeadAssets = void 0;
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * The cache of prefetched stylesheets and scripts.
 */
const headElements = exports.headElements = new Map();

/**
 * Helper to update only the necessary tags in the head.
 *
 * @async
 * @param newHead The head elements of the new page.
 */
const updateHead = async newHead => {
  // Helper to get the tag id store in the cache.
  const getTagId = tag => tag.id || tag.outerHTML;

  // Map incoming head tags by their content.
  const newHeadMap = new Map();
  for (const child of newHead) {
    newHeadMap.set(getTagId(child), child);
  }
  const toRemove = [];

  // Detect nodes that should be added or removed.
  for (const child of document.head.children) {
    const id = getTagId(child);
    // Always remove styles and links as they might change.
    if (child.nodeName === 'LINK' || child.nodeName === 'STYLE') {
      toRemove.push(child);
    } else if (newHeadMap.has(id)) {
      newHeadMap.delete(id);
    } else if (child.nodeName !== 'SCRIPT' && child.nodeName !== 'META') {
      toRemove.push(child);
    }
  }
  await Promise.all([...headElements.entries()].filter(([, {
    tag
  }]) => tag.nodeName === 'SCRIPT').map(async ([url]) => {
    await (specifier => new Promise(r => r(`${specifier}`)).then(s => _interopRequireWildcard(require(s))))(/* webpackIgnore: true */url);
  }));

  // Prepare new assets.
  const toAppend = [...newHeadMap.values()];

  // Apply the changes.
  toRemove.forEach(n => n.remove());
  document.head.append(...toAppend);
};

/**
 * Fetches and processes head assets (stylesheets and scripts) from a specified document.
 *
 * @async
 * @param doc The document from which to fetch head assets. It should support standard DOM querying methods.
 *
 * @return Returns an array of HTML elements representing the head assets.
 */
exports.updateHead = updateHead;
const fetchHeadAssets = async doc => {
  const headTags = [];

  // We only want to fetch module scripts because regular scripts (without
  // `async` or `defer` attributes) can depend on the execution of other scripts.
  // Scripts found in the head are blocking and must be executed in order.
  const scripts = doc.querySelectorAll('script[type="module"][src]');
  scripts.forEach(script => {
    const src = script.getAttribute('src');
    if (!headElements.has(src)) {
      // add the <link> elements to prefetch the module scripts
      const link = doc.createElement('link');
      link.rel = 'modulepreload';
      link.href = src;
      document.head.append(link);
      headElements.set(src, {
        tag: script
      });
    }
  });
  const stylesheets = doc.querySelectorAll('link[rel=stylesheet]');
  await Promise.all(Array.from(stylesheets).map(async tag => {
    const href = tag.getAttribute('href');
    if (!href) {
      return;
    }
    if (!headElements.has(href)) {
      try {
        const response = await fetch(href);
        const text = await response.text();
        headElements.set(href, {
          tag,
          text
        });
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error(e);
      }
    }
    const headElement = headElements.get(href);
    const styleElement = doc.createElement('style');
    styleElement.textContent = headElement.text;
    headTags.push(styleElement);
  }));
  return [doc.querySelector('title'), ...doc.querySelectorAll('style'), ...headTags];
};
exports.fetchHeadAssets = fetchHeadAssets;
//# sourceMappingURL=head.js.map