"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllPatternsDependants = exports.checkAllowListRecursive = exports.checkAllowList = void 0;
exports.getGrammar = getGrammar;
exports.getInsertBlockTypeDependants = void 0;
exports.getParsedPattern = getParsedPattern;
exports.isFiltered = void 0;
var _blocks = require("@wordpress/blocks");
var _blockSerializationDefaultParser = require("@wordpress/block-serialization-default-parser");
var _privateKeys = require("./private-keys");
var _lockUnlock = require("../lock-unlock");
var _constants = require("./constants");
var _privateSelectors = require("./private-selectors");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const isFiltered = exports.isFiltered = Symbol('isFiltered');
const parsedPatternCache = new WeakMap();
const grammarMapCache = new WeakMap();
function parsePattern(pattern) {
  const blocks = (0, _blocks.parse)(pattern.content, {
    __unstableSkipMigrationLogs: true
  });
  if (blocks.length === 1) {
    blocks[0].attributes = {
      ...blocks[0].attributes,
      metadata: {
        ...(blocks[0].attributes.metadata || {}),
        categories: pattern.categories,
        patternName: pattern.name,
        name: blocks[0].attributes.metadata?.name || pattern.title
      }
    };
  }
  return {
    ...pattern,
    blocks
  };
}
function getParsedPattern(pattern) {
  let parsedPattern = parsedPatternCache.get(pattern);
  if (!parsedPattern) {
    parsedPattern = parsePattern(pattern);
    parsedPatternCache.set(pattern, parsedPattern);
  }
  return parsedPattern;
}
function getGrammar(pattern) {
  let grammarMap = grammarMapCache.get(pattern);
  if (!grammarMap) {
    grammarMap = (0, _blockSerializationDefaultParser.parse)(pattern.content);
    // Block names are null only at the top level for whitespace.
    grammarMap = grammarMap.filter(block => block.blockName !== null);
    grammarMapCache.set(pattern, grammarMap);
  }
  return grammarMap;
}
const checkAllowList = (list, item, defaultResult = null) => {
  if (typeof list === 'boolean') {
    return list;
  }
  if (Array.isArray(list)) {
    // TODO: when there is a canonical way to detect that we are editing a post
    // the following check should be changed to something like:
    // if ( list.includes( 'core/post-content' ) && getEditorMode() === 'post-content' && item === null )
    if (list.includes('core/post-content') && item === null) {
      return true;
    }
    return list.includes(item);
  }
  return defaultResult;
};
exports.checkAllowList = checkAllowList;
const checkAllowListRecursive = (blocks, allowedBlockTypes) => {
  if (typeof allowedBlockTypes === 'boolean') {
    return allowedBlockTypes;
  }
  const blocksQueue = [...blocks];
  while (blocksQueue.length > 0) {
    const block = blocksQueue.shift();
    const isAllowed = checkAllowList(allowedBlockTypes, block.name || block.blockName, true);
    if (!isAllowed) {
      return false;
    }
    block.innerBlocks?.forEach(innerBlock => {
      blocksQueue.push(innerBlock);
    });
  }
  return true;
};
exports.checkAllowListRecursive = checkAllowListRecursive;
const getAllPatternsDependants = select => state => {
  return [state.settings.__experimentalBlockPatterns, state.settings.__experimentalUserPatternCategories, state.settings.__experimentalReusableBlocks, state.settings[_privateKeys.selectBlockPatternsKey]?.(select), state.blockPatterns, (0, _lockUnlock.unlock)(select(_constants.STORE_NAME)).getReusableBlocks()];
};
exports.getAllPatternsDependants = getAllPatternsDependants;
const getInsertBlockTypeDependants = select => (state, rootClientId) => {
  return [state.blockListSettings[rootClientId], state.blocks.byClientId.get(rootClientId), state.settings.allowedBlockTypes, state.settings.templateLock, state.blockEditingModes, select(_constants.STORE_NAME).__unstableGetEditorMode(state), (0, _privateSelectors.getSectionRootClientId)(state)];
};
exports.getInsertBlockTypeDependants = getInsertBlockTypeDependants;
//# sourceMappingURL=utils.js.map