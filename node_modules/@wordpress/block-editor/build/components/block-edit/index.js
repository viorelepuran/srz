"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BlockEdit;
Object.defineProperty(exports, "useBlockEditContext", {
  enumerable: true,
  get: function () {
    return _context.useBlockEditContext;
  }
});
var _element = require("@wordpress/element");
var _blocks = require("@wordpress/blocks");
var _edit = _interopRequireDefault(require("./edit"));
var _context = require("./context");
var _multipleUsageWarning = require("./multiple-usage-warning");
var _privateBlockContext = require("../block-list/private-block-context");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * The `useBlockEditContext` hook provides information about the block this hook is being used in.
 * It returns an object with the `name`, `isSelected` state, and the `clientId` of the block.
 * It is useful if you want to create custom hooks that need access to the current blocks clientId
 * but don't want to rely on the data getting passed in as a parameter.
 *
 * @return {Object} Block edit context
 */function BlockEdit({
  mayDisplayControls,
  mayDisplayParentControls,
  blockEditingMode,
  isPreviewMode,
  // The remaining props are passed through the BlockEdit filters and are thus
  // public API!
  ...props
}) {
  const {
    name,
    isSelected,
    clientId,
    attributes = {},
    __unstableLayoutClassNames
  } = props;
  const {
    layout = null,
    metadata = {}
  } = attributes;
  const {
    bindings
  } = metadata;
  const layoutSupport = (0, _blocks.hasBlockSupport)(name, 'layout', false) || (0, _blocks.hasBlockSupport)(name, '__experimentalLayout', false);
  const {
    originalBlockClientId
  } = (0, _element.useContext)(_privateBlockContext.PrivateBlockContext);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_context.BlockEditContextProvider
  // It is important to return the same object if props haven't
  // changed to avoid  unnecessary rerenders.
  // See https://reactjs.org/docs/context.html#caveats.
  , {
    value: (0, _element.useMemo)(() => ({
      name,
      isSelected,
      clientId,
      layout: layoutSupport ? layout : null,
      __unstableLayoutClassNames,
      // We use symbols in favour of an __unstable prefix to avoid
      // usage outside of the package (this context is exposed).
      [_context.mayDisplayControlsKey]: mayDisplayControls,
      [_context.mayDisplayParentControlsKey]: mayDisplayParentControls,
      [_context.blockEditingModeKey]: blockEditingMode,
      [_context.blockBindingsKey]: bindings,
      [_context.isPreviewModeKey]: isPreviewMode
    }), [name, isSelected, clientId, layoutSupport, layout, __unstableLayoutClassNames, mayDisplayControls, mayDisplayParentControls, blockEditingMode, bindings, isPreviewMode]),
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_edit.default, {
      ...props
    }), originalBlockClientId && /*#__PURE__*/(0, _jsxRuntime.jsx)(_multipleUsageWarning.MultipleUsageWarning, {
      originalBlockClientId: originalBlockClientId,
      name: name,
      onReplace: props.onReplace
    })]
  });
}
//# sourceMappingURL=index.js.map