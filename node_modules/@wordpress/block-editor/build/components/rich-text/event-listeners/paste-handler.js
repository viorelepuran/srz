"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _blocks = require("@wordpress/blocks");
var _richText = require("@wordpress/rich-text");
var _url = require("@wordpress/url");
var _utils = require("../utils");
var _pasting = require("../../../utils/pasting");
/**
 * WordPress dependencies
 */
/**
 * Internal dependencies
 */
/** @typedef {import('@wordpress/rich-text').RichTextValue} RichTextValue */
var _default = props => element => {
  function _onPaste(event) {
    const {
      disableFormats,
      onChange,
      value,
      formatTypes,
      tagName,
      onReplace,
      __unstableEmbedURLOnPaste,
      preserveWhiteSpace,
      pastePlainText
    } = props.current;

    // The event listener is attached to the window, so we need to check if
    // the target is the element or inside the element.
    if (!element.contains(event.target)) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    const {
      plainText,
      html
    } = (0, _pasting.getPasteEventData)(event);
    event.preventDefault();

    // Allows us to ask for this information when we get a report.
    window.console.log('Received HTML:\n\n', html);
    window.console.log('Received plain text:\n\n', plainText);
    if (disableFormats) {
      onChange((0, _richText.insert)(value, plainText));
      return;
    }
    const isInternal = event.clipboardData.getData('rich-text') === 'true';
    function pasteInline(content) {
      const transformed = formatTypes.reduce((accumulator, {
        __unstablePasteRule
      }) => {
        // Only allow one transform.
        if (__unstablePasteRule && accumulator === value) {
          accumulator = __unstablePasteRule(value, {
            html,
            plainText
          });
        }
        return accumulator;
      }, value);
      if (transformed !== value) {
        onChange(transformed);
      } else {
        const valueToInsert = (0, _richText.create)({
          html: content
        });
        (0, _utils.addActiveFormats)(valueToInsert, value.activeFormats);
        onChange((0, _richText.insert)(value, valueToInsert));
      }
    }

    // If the data comes from a rich text instance, we can directly use it
    // without filtering the data. The filters are only meant for externally
    // pasted content and remove inline styles.
    if (isInternal) {
      pasteInline(html);
      return;
    }
    if (pastePlainText) {
      onChange((0, _richText.insert)(value, (0, _richText.create)({
        text: plainText
      })));
      return;
    }
    let mode = 'INLINE';
    const trimmedPlainText = plainText.trim();
    if (__unstableEmbedURLOnPaste && (0, _richText.isEmpty)(value) && (0, _url.isURL)(trimmedPlainText) &&
    // For the link pasting feature, allow only http(s) protocols.
    /^https?:/.test(trimmedPlainText)) {
      mode = 'BLOCKS';
    }
    const content = (0, _blocks.pasteHandler)({
      HTML: html,
      plainText,
      mode,
      tagName,
      preserveWhiteSpace
    });
    if (typeof content === 'string') {
      pasteInline(content);
    } else if (content.length > 0) {
      if (onReplace && (0, _richText.isEmpty)(value)) {
        onReplace(content, content.length - 1, -1);
      }
    }
  }
  const {
    defaultView
  } = element.ownerDocument;

  // Attach the listener to the window so parent elements have the chance to
  // prevent the default behavior.
  defaultView.addEventListener('paste', _onPaste);
  return () => {
    defaultView.removeEventListener('paste', _onPaste);
  };
};
exports.default = _default;
//# sourceMappingURL=paste-handler.js.map