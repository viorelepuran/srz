"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _keycodes = require("@wordpress/keycodes");
var _richText = require("@wordpress/rich-text");
/**
 * WordPress dependencies
 */
var _default = props => element => {
  function onKeyDown(event) {
    const {
      keyCode,
      shiftKey,
      ctrlKey,
      metaKey
    } = event;
    if (event.defaultPrevented) {
      return;
    }
    const {
      value,
      onMerge,
      onRemove
    } = props.current;
    if (keyCode === _keycodes.DELETE || keyCode === _keycodes.BACKSPACE) {
      const {
        start,
        end,
        text
      } = value;
      const isReverse = keyCode === _keycodes.BACKSPACE;
      const hasActiveFormats = value.activeFormats && !!value.activeFormats.length;

      // Only process delete if the key press occurs at an uncollapsed edge.
      if (!(0, _richText.isCollapsed)(value) || hasActiveFormats || isReverse && start !== 0 || !isReverse && end !== text.length) {
        return;
      }

      // Exclude (command|ctrl)+shift+backspace as they are shortcuts for deleting blocks.
      if (shiftKey && (ctrlKey || metaKey)) {
        return;
      }
      if (onMerge) {
        onMerge(!isReverse);
      }

      // Only handle remove on Backspace. This serves dual-purpose of being
      // an intentional user interaction distinguishing between Backspace and
      // Delete to remove the empty field, but also to avoid merge & remove
      // causing destruction of two fields (merge, then removed merged).
      else if (onRemove && (0, _richText.isEmpty)(value) && isReverse) {
        onRemove(!isReverse);
      }
      event.preventDefault();
    }
  }
  element.addEventListener('keydown', onKeyDown);
  return () => {
    element.removeEventListener('keydown', onKeyDown);
  };
};
exports.default = _default;
//# sourceMappingURL=delete.js.map