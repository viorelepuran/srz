"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _data = require("@wordpress/data");
var _blocks = require("@wordpress/blocks");
var _element = require("@wordpress/element");
var _searchItems = require("../components/inserter/search-items");
var _useBlockTypesState = _interopRequireDefault(require("../components/inserter/hooks/use-block-types-state"));
var _blockIcon = _interopRequireDefault(require("../components/block-icon"));
var _store = require("../store");
var _sorting = require("../utils/sorting");
var _orderInserterBlockItems = require("../utils/order-inserter-block-items");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const noop = () => {};
const SHOWN_BLOCK_TYPES = 9;

/**
 * Creates a blocks repeater for replacing the current block with a selected block type.
 *
 * @return {Object} A blocks completer.
 */
function createBlockCompleter() {
  return {
    name: 'blocks',
    className: 'block-editor-autocompleters__block',
    triggerPrefix: '/',
    useItems(filterValue) {
      const {
        rootClientId,
        selectedBlockId,
        prioritizedBlocks
      } = (0, _data.useSelect)(select => {
        const {
          getSelectedBlockClientId,
          getBlock,
          getBlockListSettings,
          getBlockRootClientId
        } = select(_store.store);
        const {
          getActiveBlockVariation
        } = select(_blocks.store);
        const selectedBlockClientId = getSelectedBlockClientId();
        const {
          name: blockName,
          attributes
        } = getBlock(selectedBlockClientId);
        const activeBlockVariation = getActiveBlockVariation(blockName, attributes);
        const _rootClientId = getBlockRootClientId(selectedBlockClientId);
        return {
          selectedBlockId: activeBlockVariation ? `${blockName}/${activeBlockVariation.name}` : blockName,
          rootClientId: _rootClientId,
          prioritizedBlocks: getBlockListSettings(_rootClientId)?.prioritizedInserterBlocks
        };
      }, []);
      const [items, categories, collections] = (0, _useBlockTypesState.default)(rootClientId, noop, true);
      const filteredItems = (0, _element.useMemo)(() => {
        const initialFilteredItems = !!filterValue.trim() ? (0, _searchItems.searchBlockItems)(items, categories, collections, filterValue) : (0, _orderInserterBlockItems.orderInserterBlockItems)((0, _sorting.orderBy)(items, 'frecency', 'desc'), prioritizedBlocks);
        return initialFilteredItems.filter(item => item.id !== selectedBlockId).slice(0, SHOWN_BLOCK_TYPES);
      }, [filterValue, selectedBlockId, items, categories, collections, prioritizedBlocks]);
      const options = (0, _element.useMemo)(() => filteredItems.map(blockItem => {
        const {
          title,
          icon,
          isDisabled
        } = blockItem;
        return {
          key: `block-${blockItem.id}`,
          value: blockItem,
          label: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_blockIcon.default, {
              icon: icon,
              showColors: true
            }, "icon"), title]
          }),
          isDisabled
        };
      }), [filteredItems]);
      return [options];
    },
    allowContext(before, after) {
      return !(/\S/.test(before) || /\S/.test(after));
    },
    getOptionCompletion(inserterItem) {
      const {
        name,
        initialAttributes,
        innerBlocks,
        syncStatus,
        content
      } = inserterItem;
      return {
        action: 'replace',
        value: syncStatus === 'unsynced' ? (0, _blocks.parse)(content, {
          __unstableSkipMigrationLogs: true
        }) : (0, _blocks.createBlock)(name, initialAttributes, (0, _blocks.createBlocksFromInnerBlocksTemplate)(innerBlocks))
      };
    }
  };
}

/**
 * Creates a blocks repeater for replacing the current block with a selected block type.
 *
 * @return {Object} A blocks completer.
 */
var _default = exports.default = createBlockCompleter();
//# sourceMappingURL=block.js.map