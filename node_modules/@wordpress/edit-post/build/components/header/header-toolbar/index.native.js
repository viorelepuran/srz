"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNative = require("react-native");
var _element = require("@wordpress/element");
var _compose = require("@wordpress/compose");
var _data = require("@wordpress/data");
var _viewport = require("@wordpress/viewport");
var _i18n = require("@wordpress/i18n");
var _blockEditor = require("@wordpress/block-editor");
var _components = require("@wordpress/components");
var _icons = require("@wordpress/icons");
var _editor = require("@wordpress/editor");
var _blocks = require("@wordpress/blocks");
var _reactNativeBridge = require("@wordpress/react-native-bridge");
var _style = _interopRequireDefault(require("./style.scss"));
var _store = require("../../../store");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const shadowStyle = {
  shadowOffset: {
    width: 2,
    height: 2
  },
  shadowOpacity: 1,
  shadowRadius: 6,
  elevation: 18
};
function HeaderToolbar({
  hasRedo,
  hasUndo,
  redo,
  undo,
  showInserter,
  showKeyboardHideButton,
  insertBlock,
  onHideKeyboard,
  isRTL,
  noContentSelected
}) {
  const anchorNodeRef = (0, _element.useRef)();
  const containerStyle = [(0, _compose.usePreferredColorSchemeStyle)(_style.default['header-toolbar__container'], _style.default['header-toolbar__container--dark']), {
    borderTopWidth: _reactNative.StyleSheet.hairlineWidth
  }];
  (0, _element.useEffect)(() => {
    const onUndoSubscription = (0, _reactNativeBridge.subscribeOnUndoPressed)(undo);
    const onRedoSubscription = (0, _reactNativeBridge.subscribeOnRedoPressed)(redo);
    return () => {
      onUndoSubscription?.remove();
      onRedoSubscription?.remove();
    };
  }, [undo, redo]);
  (0, _element.useEffect)(() => {
    (0, _reactNativeBridge.toggleUndoButton)(!hasUndo);
  }, [hasUndo]);
  (0, _element.useEffect)(() => {
    (0, _reactNativeBridge.toggleRedoButton)(!hasRedo);
  }, [hasRedo]);
  const scrollViewRef = (0, _element.useRef)(null);
  const scrollToStart = () => {
    // scrollview doesn't seem to automatically adjust to RTL on Android so, scroll to end when Android
    if (_element.Platform.isAndroid && isRTL) {
      scrollViewRef.current.scrollToEnd();
    } else {
      scrollViewRef.current.scrollTo({
        x: 0
      });
    }
  };
  const onInsertBlock = (0, _element.useCallback)(blockType => () => {
    insertBlock((0, _blocks.createBlock)(blockType), undefined, undefined, true, {
      source: 'inserter_menu',
      inserterMethod: 'quick-inserter'
    });
  }, [insertBlock]);
  const renderMediaButtons = /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.ToolbarGroup, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ToolbarButton, {
      title: (0, _i18n.__)('Image'),
      icon: _icons.media,
      onClick: onInsertBlock('core/image'),
      testID: "insert-image-button",
      extraProps: {
        hint: (0, _i18n.__)('Insert Image Block')
      }
    }, "imageButton"), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ToolbarButton, {
      title: (0, _i18n.__)('Video'),
      icon: _icons.video,
      onClick: onInsertBlock('core/video'),
      testID: "insert-video-button",
      extraProps: {
        hint: (0, _i18n.__)('Insert Video Block')
      }
    }, "videoButton"), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ToolbarButton, {
      title: (0, _i18n.__)('Gallery'),
      icon: _icons.gallery,
      onClick: onInsertBlock('core/gallery'),
      testID: "insert-gallery-button",
      extraProps: {
        hint: (0, _i18n.__)('Insert Gallery Block')
      }
    }, "galleryButton"), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ToolbarButton, {
      title: (0, _i18n.__)('Audio'),
      icon: _icons.audio,
      onClick: onInsertBlock('core/audio'),
      testID: "insert-audio-button",
      extraProps: {
        hint: (0, _i18n.__)('Insert Audio Block')
      }
    }, "audioButton")]
  });

  /* translators: accessibility text for the editor toolbar */
  const toolbarAriaLabel = (0, _i18n.__)('Document tools');
  const shadowColor = (0, _compose.usePreferredColorSchemeStyle)(_style.default['header-toolbar__keyboard-hide-shadow--light'], _style.default['header-toolbar__keyboard-hide-shadow--dark']);
  const showKeyboardButtonStyles = [(0, _compose.usePreferredColorSchemeStyle)(_style.default['header-toolbar__keyboard-hide-container'], _style.default['header-toolbar__keyboard-hide-container--dark']), shadowStyle, {
    shadowColor: _element.Platform.isAndroid ? _style.default['header-toolbar__keyboard-hide-shadow--solid'].color : shadowColor.color
  }];
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
    ref: anchorNodeRef,
    testID: toolbarAriaLabel,
    accessibilityLabel: toolbarAriaLabel,
    style: containerStyle,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.ScrollView, {
      ref: scrollViewRef,
      onContentSizeChange: scrollToStart,
      horizontal: true,
      showsHorizontalScrollIndicator: false,
      keyboardShouldPersistTaps: "always",
      alwaysBounceHorizontal: false,
      contentContainerStyle: _style.default['header-toolbar__scrollable-content'],
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_blockEditor.Inserter, {
        disabled: !showInserter
      }), noContentSelected && renderMediaButtons, /*#__PURE__*/(0, _jsxRuntime.jsx)(_blockEditor.BlockToolbar, {
        anchorNodeRef: anchorNodeRef.current
      })]
    }), showKeyboardHideButton && /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ToolbarGroup, {
      passedStyle: showKeyboardButtonStyles,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.ToolbarButton, {
        title: (0, _i18n.__)('Hide keyboard'),
        icon: _icons.keyboardClose,
        onClick: onHideKeyboard,
        extraProps: {
          hint: (0, _i18n.__)('Tap to hide the keyboard')
        }
      })
    })]
  });
}
var _default = exports.default = (0, _compose.compose)([(0, _data.withSelect)(select => {
  const {
    getBlockRootClientId,
    getBlockSelectionEnd,
    hasInserterItems,
    hasSelectedBlock
  } = select(_blockEditor.store);
  const {
    getEditorSettings
  } = select(_editor.store);
  const isAnyBlockSelected = hasSelectedBlock();
  return {
    hasRedo: select(_editor.store).hasEditorRedo(),
    hasUndo: select(_editor.store).hasEditorUndo(),
    // This setting (richEditingEnabled) should not live in the block editor's setting.
    showInserter: select(_store.store).getEditorMode() === 'visual' && getEditorSettings().richEditingEnabled && hasInserterItems(getBlockRootClientId(getBlockSelectionEnd())),
    isTextModeEnabled: select(_store.store).getEditorMode() === 'text',
    isRTL: select(_blockEditor.store).getSettings().isRTL,
    noContentSelected: !isAnyBlockSelected
  };
}), (0, _data.withDispatch)(dispatch => {
  const {
    clearSelectedBlock,
    insertBlock
  } = dispatch(_blockEditor.store);
  const {
    togglePostTitleSelection
  } = dispatch(_editor.store);
  return {
    redo: dispatch(_editor.store).redo,
    undo: dispatch(_editor.store).undo,
    onHideKeyboard() {
      clearSelectedBlock();
      togglePostTitleSelection(false);
    },
    insertBlock
  };
}), (0, _viewport.withViewportMatch)({
  isLargeViewport: 'medium'
})])(HeaderToolbar);
//# sourceMappingURL=index.native.js.map