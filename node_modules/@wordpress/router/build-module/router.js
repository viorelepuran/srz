/* wp:polyfill */
/**
 * External dependencies
 */
import RouteRecognizer from 'route-recognizer';
import { createBrowserHistory } from 'history';

/**
 * WordPress dependencies
 */
import { createContext, useContext, useSyncExternalStore, useMemo } from '@wordpress/element';
import { addQueryArgs, getQueryArgs, getPath, buildQueryString } from '@wordpress/url';
import { useEvent } from '@wordpress/compose';

/**
 * Internal dependencies
 */
import { jsx as _jsx } from "react/jsx-runtime";
const history = createBrowserHistory();
const RoutesContext = createContext(null);
export const ConfigContext = createContext({
  pathArg: 'p'
});
const locationMemo = new WeakMap();
function getLocationWithQuery() {
  const location = history.location;
  let locationWithQuery = locationMemo.get(location);
  if (!locationWithQuery) {
    locationWithQuery = {
      ...location,
      query: Object.fromEntries(new URLSearchParams(location.search))
    };
    locationMemo.set(location, locationWithQuery);
  }
  return locationWithQuery;
}
export function useLocation() {
  const context = useContext(RoutesContext);
  if (!context) {
    throw new Error('useLocation must be used within a RouterProvider');
  }
  return context;
}
export function useHistory() {
  const {
    pathArg,
    beforeNavigate
  } = useContext(ConfigContext);
  const navigate = useEvent(async (rawPath, options = {}) => {
    var _getPath;
    const query = getQueryArgs(rawPath);
    const path = (_getPath = getPath('http://domain.com/' + rawPath)) !== null && _getPath !== void 0 ? _getPath : '';
    const performPush = () => {
      const result = beforeNavigate ? beforeNavigate({
        path,
        query
      }) : {
        path,
        query
      };
      return history.push({
        search: buildQueryString({
          [pathArg]: result.path,
          ...result.query
        })
      }, options.state);
    };

    /*
     * Skip transition in mobile, otherwise it crashes the browser.
     * See: https://github.com/WordPress/gutenberg/pull/63002.
     */
    const isMediumOrBigger = window.matchMedia('(min-width: 782px)').matches;
    if (!isMediumOrBigger || !document.startViewTransition || !options.transition) {
      performPush();
      return;
    }
    await new Promise(resolve => {
      var _options$transition;
      const classname = (_options$transition = options.transition) !== null && _options$transition !== void 0 ? _options$transition : '';
      document.documentElement.classList.add(classname);
      const transition = document.startViewTransition(() => performPush());
      transition.finished.finally(() => {
        document.documentElement.classList.remove(classname);
        resolve();
      });
    });
  });
  return useMemo(() => ({
    navigate,
    back: history.back
  }), [navigate]);
}
export default function useMatch(location, matcher, pathArg, matchResolverArgs) {
  const {
    query: rawQuery = {}
  } = location;
  return useMemo(() => {
    const {
      [pathArg]: path = '/',
      ...query
    } = rawQuery;
    const result = matcher.recognize(path)?.[0];
    if (!result) {
      return {
        name: '404',
        path: addQueryArgs(path, query),
        areas: {},
        widths: {},
        query,
        params: {}
      };
    }
    const matchedRoute = result.handler;
    const resolveFunctions = (record = {}) => {
      return Object.fromEntries(Object.entries(record).map(([key, value]) => {
        if (typeof value === 'function') {
          return [key, value({
            query,
            params: result.params,
            ...matchResolverArgs
          })];
        }
        return [key, value];
      }));
    };
    return {
      name: matchedRoute.name,
      areas: resolveFunctions(matchedRoute.areas),
      widths: resolveFunctions(matchedRoute.widths),
      params: result.params,
      query,
      path: addQueryArgs(path, query)
    };
  }, [matcher, rawQuery, pathArg, matchResolverArgs]);
}
export function RouterProvider({
  routes,
  pathArg,
  beforeNavigate,
  children,
  matchResolverArgs
}) {
  const location = useSyncExternalStore(history.listen, getLocationWithQuery, getLocationWithQuery);
  const matcher = useMemo(() => {
    const ret = new RouteRecognizer();
    routes.forEach(route => {
      ret.add([{
        path: route.path,
        handler: route
      }], {
        as: route.name
      });
    });
    return ret;
  }, [routes]);
  const match = useMatch(location, matcher, pathArg, matchResolverArgs);
  const config = useMemo(() => ({
    beforeNavigate,
    pathArg
  }), [beforeNavigate, pathArg]);
  return /*#__PURE__*/_jsx(ConfigContext.Provider, {
    value: config,
    children: /*#__PURE__*/_jsx(RoutesContext.Provider, {
      value: match,
      children: children
    })
  });
}
//# sourceMappingURL=router.js.map