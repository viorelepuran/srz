/* wp:polyfill */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConfigContext = void 0;
exports.RouterProvider = RouterProvider;
exports.default = useMatch;
exports.useHistory = useHistory;
exports.useLocation = useLocation;
var _routeRecognizer = _interopRequireDefault(require("route-recognizer"));
var _history = require("history");
var _element = require("@wordpress/element");
var _url = require("@wordpress/url");
var _compose = require("@wordpress/compose");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const history = (0, _history.createBrowserHistory)();
const RoutesContext = (0, _element.createContext)(null);
const ConfigContext = exports.ConfigContext = (0, _element.createContext)({
  pathArg: 'p'
});
const locationMemo = new WeakMap();
function getLocationWithQuery() {
  const location = history.location;
  let locationWithQuery = locationMemo.get(location);
  if (!locationWithQuery) {
    locationWithQuery = {
      ...location,
      query: Object.fromEntries(new URLSearchParams(location.search))
    };
    locationMemo.set(location, locationWithQuery);
  }
  return locationWithQuery;
}
function useLocation() {
  const context = (0, _element.useContext)(RoutesContext);
  if (!context) {
    throw new Error('useLocation must be used within a RouterProvider');
  }
  return context;
}
function useHistory() {
  const {
    pathArg,
    beforeNavigate
  } = (0, _element.useContext)(ConfigContext);
  const navigate = (0, _compose.useEvent)(async (rawPath, options = {}) => {
    var _getPath;
    const query = (0, _url.getQueryArgs)(rawPath);
    const path = (_getPath = (0, _url.getPath)('http://domain.com/' + rawPath)) !== null && _getPath !== void 0 ? _getPath : '';
    const performPush = () => {
      const result = beforeNavigate ? beforeNavigate({
        path,
        query
      }) : {
        path,
        query
      };
      return history.push({
        search: (0, _url.buildQueryString)({
          [pathArg]: result.path,
          ...result.query
        })
      }, options.state);
    };

    /*
     * Skip transition in mobile, otherwise it crashes the browser.
     * See: https://github.com/WordPress/gutenberg/pull/63002.
     */
    const isMediumOrBigger = window.matchMedia('(min-width: 782px)').matches;
    if (!isMediumOrBigger || !document.startViewTransition || !options.transition) {
      performPush();
      return;
    }
    await new Promise(resolve => {
      var _options$transition;
      const classname = (_options$transition = options.transition) !== null && _options$transition !== void 0 ? _options$transition : '';
      document.documentElement.classList.add(classname);
      const transition = document.startViewTransition(() => performPush());
      transition.finished.finally(() => {
        document.documentElement.classList.remove(classname);
        resolve();
      });
    });
  });
  return (0, _element.useMemo)(() => ({
    navigate,
    back: history.back
  }), [navigate]);
}
function useMatch(location, matcher, pathArg, matchResolverArgs) {
  const {
    query: rawQuery = {}
  } = location;
  return (0, _element.useMemo)(() => {
    const {
      [pathArg]: path = '/',
      ...query
    } = rawQuery;
    const result = matcher.recognize(path)?.[0];
    if (!result) {
      return {
        name: '404',
        path: (0, _url.addQueryArgs)(path, query),
        areas: {},
        widths: {},
        query,
        params: {}
      };
    }
    const matchedRoute = result.handler;
    const resolveFunctions = (record = {}) => {
      return Object.fromEntries(Object.entries(record).map(([key, value]) => {
        if (typeof value === 'function') {
          return [key, value({
            query,
            params: result.params,
            ...matchResolverArgs
          })];
        }
        return [key, value];
      }));
    };
    return {
      name: matchedRoute.name,
      areas: resolveFunctions(matchedRoute.areas),
      widths: resolveFunctions(matchedRoute.widths),
      params: result.params,
      query,
      path: (0, _url.addQueryArgs)(path, query)
    };
  }, [matcher, rawQuery, pathArg, matchResolverArgs]);
}
function RouterProvider({
  routes,
  pathArg,
  beforeNavigate,
  children,
  matchResolverArgs
}) {
  const location = (0, _element.useSyncExternalStore)(history.listen, getLocationWithQuery, getLocationWithQuery);
  const matcher = (0, _element.useMemo)(() => {
    const ret = new _routeRecognizer.default();
    routes.forEach(route => {
      ret.add([{
        path: route.path,
        handler: route
      }], {
        as: route.name
      });
    });
    return ret;
  }, [routes]);
  const match = useMatch(location, matcher, pathArg, matchResolverArgs);
  const config = (0, _element.useMemo)(() => ({
    beforeNavigate,
    pathArg
  }), [beforeNavigate, pathArg]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(ConfigContext.Provider, {
    value: config,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(RoutesContext.Provider, {
      value: match,
      children: children
    })
  });
}
//# sourceMappingURL=router.js.map