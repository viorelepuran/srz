"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerEntityAction = registerEntityAction;
exports.registerEntityField = registerEntityField;
exports.registerPostTypeSchema = void 0;
exports.setIsReady = setIsReady;
exports.unregisterEntityAction = unregisterEntityAction;
exports.unregisterEntityField = unregisterEntityField;
var _coreData = require("@wordpress/core-data");
var _hooks = require("@wordpress/hooks");
var _fields = require("@wordpress/fields");
var _store = require("../../store");
var _contentPreview = _interopRequireDefault(require("../fields/content-preview"));
var _lockUnlock = require("../../lock-unlock");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function registerEntityAction(kind, name, config) {
  return {
    type: 'REGISTER_ENTITY_ACTION',
    kind,
    name,
    config
  };
}
function unregisterEntityAction(kind, name, actionId) {
  return {
    type: 'UNREGISTER_ENTITY_ACTION',
    kind,
    name,
    actionId
  };
}
function registerEntityField(kind, name, config) {
  return {
    type: 'REGISTER_ENTITY_FIELD',
    kind,
    name,
    config
  };
}
function unregisterEntityField(kind, name, fieldId) {
  return {
    type: 'UNREGISTER_ENTITY_FIELD',
    kind,
    name,
    fieldId
  };
}
function setIsReady(kind, name) {
  return {
    type: 'SET_IS_READY',
    kind,
    name
  };
}
const registerPostTypeSchema = postType => async ({
  registry
}) => {
  const isReady = (0, _lockUnlock.unlock)(registry.select(_store.store)).isEntityReady('postType', postType);
  if (isReady) {
    return;
  }
  (0, _lockUnlock.unlock)(registry.dispatch(_store.store)).setIsReady('postType', postType);
  const postTypeConfig = await registry.resolveSelect(_coreData.store).getPostType(postType);
  const canCreate = await registry.resolveSelect(_coreData.store).canUser('create', {
    kind: 'postType',
    name: postType
  });
  const currentTheme = await registry.resolveSelect(_coreData.store).getCurrentTheme();
  const actions = [postTypeConfig.viewable ? _fields.viewPost : undefined, !!postTypeConfig.supports?.revisions ? _fields.viewPostRevisions : undefined,
  // @ts-ignore
  globalThis.IS_GUTENBERG_PLUGIN ? !['wp_template', 'wp_block', 'wp_template_part'].includes(postTypeConfig.slug) && canCreate && _fields.duplicatePost : undefined, postTypeConfig.slug === 'wp_template_part' && canCreate && currentTheme?.is_block_theme ? _fields.duplicateTemplatePart : undefined, canCreate && postTypeConfig.slug === 'wp_block' ? _fields.duplicatePattern : undefined, postTypeConfig.supports?.title ? _fields.renamePost : undefined, postTypeConfig.supports?.['page-attributes'] ? _fields.reorderPage : undefined, postTypeConfig.slug === 'wp_block' ? _fields.exportPattern : undefined, _fields.restorePost, _fields.resetPost, _fields.deletePost, _fields.trashPost, _fields.permanentlyDeletePost].filter(Boolean);
  const fields = [postTypeConfig.supports?.thumbnail && currentTheme?.theme_supports?.['post-thumbnails'] && _fields.featuredImageField, postTypeConfig.supports?.author && _fields.authorField, _fields.statusField, _fields.dateField, _fields.slugField, postTypeConfig.supports?.['page-attributes'] && _fields.parentField, postTypeConfig.supports?.comments && _fields.commentStatusField, _fields.templateField, _fields.passwordField, postTypeConfig.supports?.editor && postTypeConfig.viewable && _contentPreview.default].filter(Boolean);
  if (postTypeConfig.supports?.title) {
    let _titleField;
    if (postType === 'page') {
      _titleField = _fields.pageTitleField;
    } else if (postType === 'wp_template') {
      _titleField = _fields.templateTitleField;
    } else if (postType === 'wp_block') {
      _titleField = _fields.patternTitleField;
    } else {
      _titleField = _fields.titleField;
    }
    fields.push(_titleField);
  }
  registry.batch(() => {
    actions.forEach(action => {
      (0, _lockUnlock.unlock)(registry.dispatch(_store.store)).registerEntityAction('postType', postType, action);
    });
    fields.forEach(field => {
      (0, _lockUnlock.unlock)(registry.dispatch(_store.store)).registerEntityField('postType', postType, field);
    });
  });
  (0, _hooks.doAction)('core.registerPostTypeSchema', postType);
};
exports.registerPostTypeSchema = registerPostTypeSchema;
//# sourceMappingURL=private-actions.js.map