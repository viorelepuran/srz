"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultRenderingMode = void 0;
exports.getEntityActions = getEntityActions;
exports.getEntityFields = getEntityFields;
exports.getInserter = void 0;
exports.getInserterSidebarToggleRef = getInserterSidebarToggleRef;
exports.getListViewToggleRef = getListViewToggleRef;
exports.hasPostMetaChanges = exports.getPostIcon = exports.getPostBlocksByName = void 0;
exports.isEntityReady = isEntityReady;
var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));
var _blockEditor = require("@wordpress/block-editor");
var _data = require("@wordpress/data");
var _icons = require("@wordpress/icons");
var _coreData = require("@wordpress/core-data");
var _preferences = require("@wordpress/preferences");
var _selectors = require("./selectors");
var _privateSelectors = require("../dataviews/store/private-selectors");
var _utils = require("../utils");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const EMPTY_INSERTION_POINT = {
  rootClientId: undefined,
  insertionIndex: undefined,
  filterValue: undefined
};

/**
 * These are rendering modes that the editor supports.
 */
const RENDERING_MODES = ['post-only', 'template-locked'];

/**
 * Get the inserter.
 *
 * @param {Object} state Global application state.
 *
 * @return {Object} The root client ID, index to insert at and starting filter value.
 */
const getInserter = exports.getInserter = (0, _data.createRegistrySelector)(select => (0, _data.createSelector)(state => {
  if (typeof state.blockInserterPanel === 'object') {
    return state.blockInserterPanel;
  }
  if ((0, _selectors.getRenderingMode)(state) === 'template-locked') {
    const [postContentClientId] = select(_blockEditor.store).getBlocksByName('core/post-content');
    if (postContentClientId) {
      return {
        rootClientId: postContentClientId,
        insertionIndex: undefined,
        filterValue: undefined
      };
    }
  }
  return EMPTY_INSERTION_POINT;
}, state => {
  const [postContentClientId] = select(_blockEditor.store).getBlocksByName('core/post-content');
  return [state.blockInserterPanel, (0, _selectors.getRenderingMode)(state), postContentClientId];
}));
function getListViewToggleRef(state) {
  return state.listViewToggleRef;
}
function getInserterSidebarToggleRef(state) {
  return state.inserterSidebarToggleRef;
}
const CARD_ICONS = {
  wp_block: _icons.symbol,
  wp_navigation: _icons.navigation,
  page: _icons.page,
  post: _icons.verse
};
const getPostIcon = exports.getPostIcon = (0, _data.createRegistrySelector)(select => (state, postType, options) => {
  {
    if (postType === 'wp_template_part' || postType === 'wp_template') {
      const templateAreas = select(_coreData.store).getCurrentTheme()?.default_template_part_areas || [];
      const areaData = templateAreas.find(item => options.area === item.area);
      if (areaData?.icon) {
        return (0, _utils.getTemplatePartIcon)(areaData.icon);
      }
      return _icons.layout;
    }
    if (CARD_ICONS[postType]) {
      return CARD_ICONS[postType];
    }
    const postTypeEntity = select(_coreData.store).getPostType(postType);
    // `icon` is the `menu_icon` property of a post type. We
    // only handle `dashicons` for now, even if the `menu_icon`
    // also supports urls and svg as values.
    if (typeof postTypeEntity?.icon === 'string' && postTypeEntity.icon.startsWith('dashicons-')) {
      return postTypeEntity.icon.slice(10);
    }
    return _icons.page;
  }
});

/**
 * Returns true if there are unsaved changes to the
 * post's meta fields, and false otherwise.
 *
 * @param {Object} state    Global application state.
 * @param {string} postType The post type of the post.
 * @param {number} postId   The ID of the post.
 *
 * @return {boolean} Whether there are edits or not in the meta fields of the relevant post.
 */
const hasPostMetaChanges = exports.hasPostMetaChanges = (0, _data.createRegistrySelector)(select => (state, postType, postId) => {
  const {
    type: currentPostType,
    id: currentPostId
  } = (0, _selectors.getCurrentPost)(state);
  // If no postType or postId is passed, use the current post.
  const edits = select(_coreData.store).getEntityRecordNonTransientEdits('postType', postType || currentPostType, postId || currentPostId);
  if (!edits?.meta) {
    return false;
  }

  // Compare if anything apart from `footnotes` has changed.
  const originalPostMeta = select(_coreData.store).getEntityRecord('postType', postType || currentPostType, postId || currentPostId)?.meta;
  return !(0, _fastDeepEqual.default)({
    ...originalPostMeta,
    footnotes: undefined
  }, {
    ...edits.meta,
    footnotes: undefined
  });
});
function getEntityActions(state, ...args) {
  return (0, _privateSelectors.getEntityActions)(state.dataviews, ...args);
}
function isEntityReady(state, ...args) {
  return (0, _privateSelectors.isEntityReady)(state.dataviews, ...args);
}
function getEntityFields(state, ...args) {
  return (0, _privateSelectors.getEntityFields)(state.dataviews, ...args);
}

/**
 * Similar to getBlocksByName in @wordpress/block-editor, but only returns the top-most
 * blocks that aren't descendants of the query block.
 *
 * @param {Object}       state      Global application state.
 * @param {Array|string} blockNames Block names of the blocks to retrieve.
 *
 * @return {Array} Block client IDs.
 */
const getPostBlocksByName = exports.getPostBlocksByName = (0, _data.createRegistrySelector)(select => (0, _data.createSelector)((state, blockNames) => {
  blockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
  const {
    getBlocksByName,
    getBlockParents,
    getBlockName
  } = select(_blockEditor.store);
  return getBlocksByName(blockNames).filter(clientId => getBlockParents(clientId).every(parentClientId => {
    const parentBlockName = getBlockName(parentClientId);
    return (
      // Ignore descendents of the query block.
      parentBlockName !== 'core/query' &&
      // Enable only the top-most block.
      !blockNames.includes(parentBlockName)
    );
  }));
}, () => [select(_blockEditor.store).getBlocks()]));

/**
 * Returns the default rendering mode for a post type by user preference or post type configuration.
 *
 * @param {Object} state    Global application state.
 * @param {string} postType The post type.
 *
 * @return {string} The default rendering mode. Returns `undefined` while resolving value.
 */
const getDefaultRenderingMode = exports.getDefaultRenderingMode = (0, _data.createRegistrySelector)(select => (state, postType) => {
  const {
    getPostType,
    getCurrentTheme,
    hasFinishedResolution
  } = select(_coreData.store);

  // This needs to be called before `hasFinishedResolution`.
  // eslint-disable-next-line @wordpress/no-unused-vars-before-return
  const currentTheme = getCurrentTheme();
  // eslint-disable-next-line @wordpress/no-unused-vars-before-return
  const postTypeEntity = getPostType(postType);

  // Wait for the post type and theme resolution.
  if (!hasFinishedResolution('getPostType', [postType]) || !hasFinishedResolution('getCurrentTheme')) {
    return undefined;
  }
  const theme = currentTheme?.stylesheet;
  const defaultModePreference = select(_preferences.store).get('core', 'renderingModes')?.[theme]?.[postType];
  const postTypeDefaultMode = Array.isArray(postTypeEntity?.supports?.editor) ? postTypeEntity.supports.editor.find(features => 'default-mode' in features)?.['default-mode'] : undefined;
  const defaultMode = defaultModePreference || postTypeDefaultMode;

  // Fallback gracefully to 'post-only' when rendering mode is not supported.
  if (!RENDERING_MODES.includes(defaultMode)) {
    return 'post-only';
  }
  return defaultMode;
});
//# sourceMappingURL=private-selectors.js.map