"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PostScheduleLabel;
exports.getFullPostScheduleLabel = getFullPostScheduleLabel;
exports.getPostScheduleLabel = getPostScheduleLabel;
exports.usePostScheduleLabel = usePostScheduleLabel;
var _i18n = require("@wordpress/i18n");
var _date = require("@wordpress/date");
var _data = require("@wordpress/data");
var _store = require("../../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Renders the PostScheduleLabel component.
 *
 * @param {Object} props Props.
 *
 * @return {React.ReactNode} The rendered component.
 */
function PostScheduleLabel(props) {
  return usePostScheduleLabel(props);
}

/**
 * Custom hook to get the label for post schedule.
 *
 * @param {Object}  options      Options for the hook.
 * @param {boolean} options.full Whether to get the full label or not. Default is false.
 *
 * @return {string} The label for post schedule.
 */
function usePostScheduleLabel({
  full = false
} = {}) {
  const {
    date,
    isFloating
  } = (0, _data.useSelect)(select => ({
    date: select(_store.store).getEditedPostAttribute('date'),
    isFloating: select(_store.store).isEditedPostDateFloating()
  }), []);
  return full ? getFullPostScheduleLabel(date) : getPostScheduleLabel(date, {
    isFloating
  });
}
function getFullPostScheduleLabel(dateAttribute) {
  const date = (0, _date.getDate)(dateAttribute);
  const timezoneAbbreviation = getTimezoneAbbreviation();
  const formattedDate = (0, _date.dateI18n)(
  // translators: Use a non-breaking space between 'g:i' and 'a' if appropriate.
  (0, _i18n._x)('F j, Y g:i\xa0a', 'post schedule full date format'), date);
  return (0, _i18n.isRTL)() ? `${timezoneAbbreviation} ${formattedDate}` : `${formattedDate} ${timezoneAbbreviation}`;
}
function getPostScheduleLabel(dateAttribute, {
  isFloating = false,
  now = new Date()
} = {}) {
  if (!dateAttribute || isFloating) {
    return (0, _i18n.__)('Immediately');
  }

  // If the user timezone does not equal the site timezone then using words
  // like 'tomorrow' is confusing, so show the full date.
  if (!isTimezoneSameAsSiteTimezone(now)) {
    return getFullPostScheduleLabel(dateAttribute);
  }
  const date = (0, _date.getDate)(dateAttribute);
  if (isSameDay(date, now)) {
    return (0, _i18n.sprintf)(
    // translators: %s: Time of day the post is scheduled for.
    (0, _i18n.__)('Today at %s'),
    // translators: If using a space between 'g:i' and 'a', use a non-breaking space.
    (0, _date.dateI18n)((0, _i18n._x)('g:i\xa0a', 'post schedule time format'), date));
  }
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  if (isSameDay(date, tomorrow)) {
    return (0, _i18n.sprintf)(
    // translators: %s: Time of day the post is scheduled for.
    (0, _i18n.__)('Tomorrow at %s'),
    // translators: If using a space between 'g:i' and 'a', use a non-breaking space.
    (0, _date.dateI18n)((0, _i18n._x)('g:i\xa0a', 'post schedule time format'), date));
  }
  if (date.getFullYear() === now.getFullYear()) {
    return (0, _date.dateI18n)(
    // translators: If using a space between 'g:i' and 'a', use a non-breaking space.
    (0, _i18n._x)('F j g:i\xa0a', 'post schedule date format without year'), date);
  }
  return (0, _date.dateI18n)(
  // translators: Use a non-breaking space between 'g:i' and 'a' if appropriate.
  (0, _i18n._x)('F j, Y g:i\xa0a', 'post schedule full date format'), date);
}
function getTimezoneAbbreviation() {
  const {
    timezone
  } = (0, _date.getSettings)();
  if (timezone.abbr && isNaN(Number(timezone.abbr))) {
    return timezone.abbr;
  }
  const symbol = timezone.offset < 0 ? '' : '+';
  return `UTC${symbol}${timezone.offsetFormatted}`;
}
function isTimezoneSameAsSiteTimezone(date) {
  const {
    timezone
  } = (0, _date.getSettings)();
  const siteOffset = Number(timezone.offset);
  const dateOffset = -1 * (date.getTimezoneOffset() / 60);
  return siteOffset === dateOffset;
}
function isSameDay(left, right) {
  return left.getDate() === right.getDate() && left.getMonth() === right.getMonth() && left.getFullYear() === right.getFullYear();
}
//# sourceMappingURL=label.js.map