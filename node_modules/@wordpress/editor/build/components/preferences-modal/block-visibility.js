"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BlockVisibility;
var _data = require("@wordpress/data");
var _preferences = require("@wordpress/preferences");
var _blocks = require("@wordpress/blocks");
var _element = require("@wordpress/element");
var _blockEditor = require("@wordpress/block-editor");
var _store = require("../../store");
var _lockUnlock = require("../../lock-unlock");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const {
  BlockManager
} = (0, _lockUnlock.unlock)(_blockEditor.privateApis);
const EMPTY_ARRAY = [];
function BlockVisibility() {
  const {
    showBlockTypes,
    hideBlockTypes
  } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
  const {
    blockTypes,
    allowedBlockTypes: _allowedBlockTypes,
    hiddenBlockTypes: _hiddenBlockTypes
  } = (0, _data.useSelect)(select => {
    var _select$get;
    return {
      blockTypes: select(_blocks.store).getBlockTypes(),
      allowedBlockTypes: select(_store.store).getEditorSettings().allowedBlockTypes,
      hiddenBlockTypes: (_select$get = select(_preferences.store).get('core', 'hiddenBlockTypes')) !== null && _select$get !== void 0 ? _select$get : EMPTY_ARRAY
    };
  }, []);
  const allowedBlockTypes = (0, _element.useMemo)(() => {
    if (_allowedBlockTypes === true) {
      return blockTypes;
    }
    return blockTypes.filter(({
      name
    }) => {
      return _allowedBlockTypes?.includes(name);
    });
  }, [_allowedBlockTypes, blockTypes]);
  const filteredBlockTypes = allowedBlockTypes.filter(blockType => (0, _blocks.hasBlockSupport)(blockType, 'inserter', true) && (!blockType.parent || blockType.parent.includes('core/post-content')));

  // Some hidden blocks become unregistered
  // by removing for instance the plugin that registered them, yet
  // they're still remain as hidden by the user's action.
  // We consider "hidden", blocks which were hidden and
  // are still registered.
  const hiddenBlockTypes = _hiddenBlockTypes.filter(hiddenBlock => {
    return filteredBlockTypes.some(registeredBlock => registeredBlock.name === hiddenBlock);
  });
  const selectedBlockTypes = filteredBlockTypes.filter(blockType => !hiddenBlockTypes.includes(blockType.name));
  const onChangeSelectedBlockTypes = newSelectedBlockTypes => {
    if (selectedBlockTypes.length > newSelectedBlockTypes.length) {
      const blockTypesToHide = selectedBlockTypes.filter(blockType => !newSelectedBlockTypes.find(({
        name
      }) => name === blockType.name));
      hideBlockTypes(blockTypesToHide.map(({
        name
      }) => name));
    } else if (selectedBlockTypes.length < newSelectedBlockTypes.length) {
      const blockTypesToShow = newSelectedBlockTypes.filter(blockType => !selectedBlockTypes.find(({
        name
      }) => name === blockType.name));
      showBlockTypes(blockTypesToShow.map(({
        name
      }) => name));
    }
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(BlockManager, {
    blockTypes: filteredBlockTypes,
    selectedBlockTypes: selectedBlockTypes,
    onChange: onChangeSelectedBlockTypes
  });
}
//# sourceMappingURL=block-visibility.js.map