"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DisableNonPageContentBlocks;
var _data = require("@wordpress/data");
var _blockEditor = require("@wordpress/block-editor");
var _element = require("@wordpress/element");
var _usePostContentBlocks = _interopRequireDefault(require("./use-post-content-blocks"));
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Component that when rendered, makes it so that the site editor allows only
 * page content to be edited.
 */
function DisableNonPageContentBlocks() {
  const contentOnlyIds = (0, _usePostContentBlocks.default)();
  const {
    templateParts,
    isNavigationMode
  } = (0, _data.useSelect)(select => {
    const {
      getBlocksByName,
      isNavigationMode: _isNavigationMode
    } = select(_blockEditor.store);
    return {
      templateParts: getBlocksByName('core/template-part'),
      isNavigationMode: _isNavigationMode()
    };
  }, []);
  const disabledIds = (0, _data.useSelect)(select => {
    const {
      getBlockOrder
    } = select(_blockEditor.store);
    return templateParts.flatMap(clientId => getBlockOrder(clientId));
  }, [templateParts]);
  const registry = (0, _data.useRegistry)();

  // The code here is split into multiple `useEffects` calls.
  // This is done to avoid setting/unsetting block editing modes multiple times unnecessarily.
  //
  // For example, the block editing mode of the root block (clientId: '') only
  // needs to be set once, not when `contentOnlyIds` or `disabledIds` change.
  //
  // It's also unlikely that these different types of blocks are being inserted
  // or removed at the same time, so using different effects reflects that.
  (0, _element.useEffect)(() => {
    const {
      setBlockEditingMode,
      unsetBlockEditingMode
    } = registry.dispatch(_blockEditor.store);
    setBlockEditingMode('', 'disabled');
    return () => {
      unsetBlockEditingMode('');
    };
  }, [registry]);
  (0, _element.useEffect)(() => {
    const {
      setBlockEditingMode,
      unsetBlockEditingMode
    } = registry.dispatch(_blockEditor.store);
    registry.batch(() => {
      for (const clientId of contentOnlyIds) {
        setBlockEditingMode(clientId, 'contentOnly');
      }
    });
    return () => {
      registry.batch(() => {
        for (const clientId of contentOnlyIds) {
          unsetBlockEditingMode(clientId);
        }
      });
    };
  }, [contentOnlyIds, registry]);
  (0, _element.useEffect)(() => {
    const {
      setBlockEditingMode,
      unsetBlockEditingMode
    } = registry.dispatch(_blockEditor.store);
    registry.batch(() => {
      if (!isNavigationMode) {
        for (const clientId of templateParts) {
          setBlockEditingMode(clientId, 'contentOnly');
        }
      }
    });
    return () => {
      registry.batch(() => {
        if (!isNavigationMode) {
          for (const clientId of templateParts) {
            unsetBlockEditingMode(clientId);
          }
        }
      });
    };
  }, [templateParts, isNavigationMode, registry]);
  (0, _element.useEffect)(() => {
    const {
      setBlockEditingMode,
      unsetBlockEditingMode
    } = registry.dispatch(_blockEditor.store);
    registry.batch(() => {
      for (const clientId of disabledIds) {
        setBlockEditingMode(clientId, 'disabled');
      }
    });
    return () => {
      registry.batch(() => {
        for (const clientId of disabledIds) {
          unsetBlockEditingMode(clientId);
        }
      });
    };
  }, [disabledIds, registry]);
  return null;
}
//# sourceMappingURL=disable-non-page-content-blocks.js.map