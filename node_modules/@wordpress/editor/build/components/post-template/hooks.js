"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAllowSwitchingTemplates = useAllowSwitchingTemplates;
exports.useAvailableTemplates = useAvailableTemplates;
exports.useCurrentTemplateSlug = useCurrentTemplateSlug;
exports.useEditedPostContext = useEditedPostContext;
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _coreData = require("@wordpress/core-data");
var _store = require("../../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function useEditedPostContext() {
  return (0, _data.useSelect)(select => {
    const {
      getCurrentPostId,
      getCurrentPostType
    } = select(_store.store);
    return {
      postId: getCurrentPostId(),
      postType: getCurrentPostType()
    };
  }, []);
}
function useAllowSwitchingTemplates() {
  const {
    postType,
    postId
  } = useEditedPostContext();
  return (0, _data.useSelect)(select => {
    const {
      canUser,
      getEntityRecord,
      getEntityRecords
    } = select(_coreData.store);
    const siteSettings = canUser('read', {
      kind: 'root',
      name: 'site'
    }) ? getEntityRecord('root', 'site') : undefined;
    const isPostsPage = +postId === siteSettings?.page_for_posts;
    const isFrontPage = postType === 'page' && +postId === siteSettings?.page_on_front;
    // If current page is set front page or posts page, we also need
    // to check if the current theme has a template for it. If not
    const templates = isFrontPage ? getEntityRecords('postType', 'wp_template', {
      per_page: -1
    }) : [];
    const hasFrontPage = isFrontPage && !!templates?.some(({
      slug
    }) => slug === 'front-page');
    return !isPostsPage && !hasFrontPage;
  }, [postId, postType]);
}
function useTemplates(postType) {
  return (0, _data.useSelect)(select => select(_coreData.store).getEntityRecords('postType', 'wp_template', {
    per_page: -1,
    post_type: postType
  }), [postType]);
}
function useAvailableTemplates(postType) {
  const currentTemplateSlug = useCurrentTemplateSlug();
  const allowSwitchingTemplate = useAllowSwitchingTemplates();
  const templates = useTemplates(postType);
  return (0, _element.useMemo)(() => allowSwitchingTemplate && templates?.filter(template => template.is_custom && template.slug !== currentTemplateSlug && !!template.content.raw // Skip empty templates.
  ), [templates, currentTemplateSlug, allowSwitchingTemplate]);
}
function useCurrentTemplateSlug() {
  const {
    postType,
    postId
  } = useEditedPostContext();
  const templates = useTemplates(postType);
  const entityTemplate = (0, _data.useSelect)(select => {
    const post = select(_coreData.store).getEditedEntityRecord('postType', postType, postId);
    return post?.template;
  }, [postType, postId]);
  if (!entityTemplate) {
    return;
  }
  // If a page has a `template` set and is not included in the list
  // of the theme's templates, do not return it, in order to resolve
  // to the current theme's default template.
  return templates?.find(template => template.slug === entityTemplate)?.slug;
}
//# sourceMappingURL=hooks.js.map