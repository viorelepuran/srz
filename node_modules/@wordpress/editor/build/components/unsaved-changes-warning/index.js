"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = UnsavedChangesWarning;
var _i18n = require("@wordpress/i18n");
var _element = require("@wordpress/element");
var _data = require("@wordpress/data");
var _coreData = require("@wordpress/core-data");
/**
 * WordPress dependencies
 */

/**
 * Warns the user if there are unsaved changes before leaving the editor.
 * Compatible with Post Editor and Site Editor.
 *
 * @return {React.ReactNode} The component.
 */
function UnsavedChangesWarning() {
  const {
    __experimentalGetDirtyEntityRecords
  } = (0, _data.useSelect)(_coreData.store);
  (0, _element.useEffect)(() => {
    /**
     * Warns the user if there are unsaved changes before leaving the editor.
     *
     * @param {Event} event `beforeunload` event.
     *
     * @return {string | undefined} Warning prompt message, if unsaved changes exist.
     */
    const warnIfUnsavedChanges = event => {
      // We need to call the selector directly in the listener to avoid race
      // conditions with `BrowserURL` where `componentDidUpdate` gets the
      // new value of `isEditedPostDirty` before this component does,
      // causing this component to incorrectly think a trashed post is still dirty.
      const dirtyEntityRecords = __experimentalGetDirtyEntityRecords();
      if (dirtyEntityRecords.length > 0) {
        event.returnValue = (0, _i18n.__)('You have unsaved changes. If you proceed, they will be lost.');
        return event.returnValue;
      }
    };
    window.addEventListener('beforeunload', warnIfUnsavedChanges);
    return () => {
      window.removeEventListener('beforeunload', warnIfUnsavedChanges);
    };
  }, [__experimentalGetDirtyEntityRecords]);
  return null;
}
//# sourceMappingURL=index.js.map