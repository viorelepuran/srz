"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAvailablePatterns = useAvailablePatterns;
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _coreData = require("@wordpress/core-data");
var _blocks = require("@wordpress/blocks");
var _patterns = require("@wordpress/patterns");
var _lockUnlock = require("../../lock-unlock");
var _store = require("../../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const {
  EXCLUDED_PATTERN_SOURCES,
  PATTERN_TYPES
} = (0, _lockUnlock.unlock)(_patterns.privateApis);
function injectThemeAttributeInBlockTemplateContent(block, currentThemeStylesheet) {
  block.innerBlocks = block.innerBlocks.map(innerBlock => {
    return injectThemeAttributeInBlockTemplateContent(innerBlock, currentThemeStylesheet);
  });
  if (block.name === 'core/template-part' && block.attributes.theme === undefined) {
    block.attributes.theme = currentThemeStylesheet;
  }
  return block;
}

/**
 * Filter all patterns and return only the ones that are compatible with the current template.
 *
 * @param {Array}  patterns An array of patterns.
 * @param {Object} template The current template.
 * @return {Array} Array of patterns that are compatible with the current template.
 */
function filterPatterns(patterns, template) {
  // Filter out duplicates.
  const filterOutDuplicatesByName = (currentItem, index, items) => index === items.findIndex(item => currentItem.name === item.name);

  // Filter out core/directory patterns not included in theme.json.
  const filterOutExcludedPatternSources = pattern => !EXCLUDED_PATTERN_SOURCES.includes(pattern.source);

  // Looks for patterns that have the same template type as the current template,
  // or have a block type that matches the current template area.
  const filterCompatiblePatterns = pattern => pattern.templateTypes?.includes(template.slug) || pattern.blockTypes?.includes('core/template-part/' + template.area);
  return patterns.filter((pattern, index, items) => {
    return filterOutDuplicatesByName(pattern, index, items) && filterOutExcludedPatternSources(pattern) && filterCompatiblePatterns(pattern);
  });
}
function preparePatterns(patterns, currentThemeStylesheet) {
  return patterns.map(pattern => ({
    ...pattern,
    keywords: pattern.keywords || [],
    type: PATTERN_TYPES.theme,
    blocks: (0, _blocks.parse)(pattern.content, {
      __unstableSkipMigrationLogs: true
    }).map(block => injectThemeAttributeInBlockTemplateContent(block, currentThemeStylesheet))
  }));
}
function useAvailablePatterns(template) {
  const {
    blockPatterns,
    restBlockPatterns,
    currentThemeStylesheet
  } = (0, _data.useSelect)(select => {
    var _settings$__experimen;
    const {
      getEditorSettings
    } = select(_store.store);
    const settings = getEditorSettings();
    return {
      blockPatterns: (_settings$__experimen = settings.__experimentalAdditionalBlockPatterns) !== null && _settings$__experimen !== void 0 ? _settings$__experimen : settings.__experimentalBlockPatterns,
      restBlockPatterns: select(_coreData.store).getBlockPatterns(),
      currentThemeStylesheet: select(_coreData.store).getCurrentTheme().stylesheet
    };
  }, []);
  return (0, _element.useMemo)(() => {
    const mergedPatterns = [...(blockPatterns || []), ...(restBlockPatterns || [])];
    const filteredPatterns = filterPatterns(mergedPatterns, template);
    return preparePatterns(filteredPatterns, template, currentThemeStylesheet);
  }, [blockPatterns, restBlockPatterns, template, currentThemeStylesheet]);
}
//# sourceMappingURL=hooks.js.map