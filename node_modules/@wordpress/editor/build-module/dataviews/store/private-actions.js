/**
 * WordPress dependencies
 */
import { store as coreStore } from '@wordpress/core-data';
import { doAction } from '@wordpress/hooks';
import { viewPost, viewPostRevisions, duplicatePost, duplicatePattern, reorderPage, exportPattern, permanentlyDeletePost, restorePost, trashPost, renamePost, resetPost, deletePost, duplicateTemplatePart, featuredImageField, dateField, parentField, passwordField, commentStatusField, slugField, statusField, authorField, titleField, templateField, templateTitleField, pageTitleField, patternTitleField } from '@wordpress/fields';

/**
 * Internal dependencies
 */
import { store as editorStore } from '../../store';
import postPreviewField from '../fields/content-preview';
import { unlock } from '../../lock-unlock';
export function registerEntityAction(kind, name, config) {
  return {
    type: 'REGISTER_ENTITY_ACTION',
    kind,
    name,
    config
  };
}
export function unregisterEntityAction(kind, name, actionId) {
  return {
    type: 'UNREGISTER_ENTITY_ACTION',
    kind,
    name,
    actionId
  };
}
export function registerEntityField(kind, name, config) {
  return {
    type: 'REGISTER_ENTITY_FIELD',
    kind,
    name,
    config
  };
}
export function unregisterEntityField(kind, name, fieldId) {
  return {
    type: 'UNREGISTER_ENTITY_FIELD',
    kind,
    name,
    fieldId
  };
}
export function setIsReady(kind, name) {
  return {
    type: 'SET_IS_READY',
    kind,
    name
  };
}
export const registerPostTypeSchema = postType => async ({
  registry
}) => {
  const isReady = unlock(registry.select(editorStore)).isEntityReady('postType', postType);
  if (isReady) {
    return;
  }
  unlock(registry.dispatch(editorStore)).setIsReady('postType', postType);
  const postTypeConfig = await registry.resolveSelect(coreStore).getPostType(postType);
  const canCreate = await registry.resolveSelect(coreStore).canUser('create', {
    kind: 'postType',
    name: postType
  });
  const currentTheme = await registry.resolveSelect(coreStore).getCurrentTheme();
  const actions = [postTypeConfig.viewable ? viewPost : undefined, !!postTypeConfig.supports?.revisions ? viewPostRevisions : undefined,
  // @ts-ignore
  globalThis.IS_GUTENBERG_PLUGIN ? !['wp_template', 'wp_block', 'wp_template_part'].includes(postTypeConfig.slug) && canCreate && duplicatePost : undefined, postTypeConfig.slug === 'wp_template_part' && canCreate && currentTheme?.is_block_theme ? duplicateTemplatePart : undefined, canCreate && postTypeConfig.slug === 'wp_block' ? duplicatePattern : undefined, postTypeConfig.supports?.title ? renamePost : undefined, postTypeConfig.supports?.['page-attributes'] ? reorderPage : undefined, postTypeConfig.slug === 'wp_block' ? exportPattern : undefined, restorePost, resetPost, deletePost, trashPost, permanentlyDeletePost].filter(Boolean);
  const fields = [postTypeConfig.supports?.thumbnail && currentTheme?.theme_supports?.['post-thumbnails'] && featuredImageField, postTypeConfig.supports?.author && authorField, statusField, dateField, slugField, postTypeConfig.supports?.['page-attributes'] && parentField, postTypeConfig.supports?.comments && commentStatusField, templateField, passwordField, postTypeConfig.supports?.editor && postTypeConfig.viewable && postPreviewField].filter(Boolean);
  if (postTypeConfig.supports?.title) {
    let _titleField;
    if (postType === 'page') {
      _titleField = pageTitleField;
    } else if (postType === 'wp_template') {
      _titleField = templateTitleField;
    } else if (postType === 'wp_block') {
      _titleField = patternTitleField;
    } else {
      _titleField = titleField;
    }
    fields.push(_titleField);
  }
  registry.batch(() => {
    actions.forEach(action => {
      unlock(registry.dispatch(editorStore)).registerEntityAction('postType', postType, action);
    });
    fields.forEach(field => {
      unlock(registry.dispatch(editorStore)).registerEntityField('postType', postType, field);
    });
  });
  doAction('core.registerPostTypeSchema', postType);
};
//# sourceMappingURL=private-actions.js.map