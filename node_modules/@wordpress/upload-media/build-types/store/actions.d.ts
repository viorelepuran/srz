/**
 * WordPress dependencies
 */
import type { createRegistry } from '@wordpress/data';
type WPDataRegistry = ReturnType<typeof createRegistry>;
/**
 * Internal dependencies
 */
import type { AdditionalData, OnBatchSuccessHandler, OnChangeHandler, OnErrorHandler, OnSuccessHandler, QueueItemId, State } from './types';
import type { addItem, processItem, removeItem, revokeBlobUrls } from './private-actions';
type ActionCreators = {
    addItem: typeof addItem;
    addItems: typeof addItems;
    removeItem: typeof removeItem;
    processItem: typeof processItem;
    cancelItem: typeof cancelItem;
    revokeBlobUrls: typeof revokeBlobUrls;
    <T = Record<string, unknown>>(args: T): void;
};
type AllSelectors = typeof import('./selectors') & typeof import('./private-selectors');
type CurriedState<F> = F extends (state: State, ...args: infer P) => infer R ? (...args: P) => R : F;
type Selectors = {
    [key in keyof AllSelectors]: CurriedState<AllSelectors[key]>;
};
type ThunkArgs = {
    select: Selectors;
    dispatch: ActionCreators;
    registry: WPDataRegistry;
};
interface AddItemsArgs {
    files: File[];
    onChange?: OnChangeHandler;
    onSuccess?: OnSuccessHandler;
    onBatchSuccess?: OnBatchSuccessHandler;
    onError?: OnErrorHandler;
    additionalData?: AdditionalData;
    allowedTypes?: string[];
}
/**
 * Adds a new item to the upload queue.
 *
 * @param $0
 * @param $0.files            Files
 * @param [$0.onChange]       Function called each time a file or a temporary representation of the file is available.
 * @param [$0.onSuccess]      Function called after the file is uploaded.
 * @param [$0.onBatchSuccess] Function called after a batch of files is uploaded.
 * @param [$0.onError]        Function called when an error happens.
 * @param [$0.additionalData] Additional data to include in the request.
 * @param [$0.allowedTypes]   Array with the types of media that can be uploaded, if unset all types are allowed.
 */
export declare function addItems({ files, onChange, onSuccess, onError, onBatchSuccess, additionalData, allowedTypes, }: AddItemsArgs): ({ select, dispatch }: ThunkArgs) => Promise<void>;
/**
 * Cancels an item in the queue based on an error.
 *
 * @param id     Item ID.
 * @param error  Error instance.
 * @param silent Whether to cancel the item silently,
 *               without invoking its `onError` callback.
 */
export declare function cancelItem(id: QueueItemId, error: Error, silent?: boolean): ({ select, dispatch }: ThunkArgs) => Promise<void>;
export {};
//# sourceMappingURL=actions.d.ts.map