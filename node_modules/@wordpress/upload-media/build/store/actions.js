"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addItems = addItems;
exports.cancelItem = cancelItem;
var _uuid = require("uuid");
var _types = require("./types");
var _validateMimeType = require("../validate-mime-type");
var _validateMimeTypeForUser = require("../validate-mime-type-for-user");
var _validateFileSize = require("../validate-file-size");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Adds a new item to the upload queue.
 *
 * @param $0
 * @param $0.files            Files
 * @param [$0.onChange]       Function called each time a file or a temporary representation of the file is available.
 * @param [$0.onSuccess]      Function called after the file is uploaded.
 * @param [$0.onBatchSuccess] Function called after a batch of files is uploaded.
 * @param [$0.onError]        Function called when an error happens.
 * @param [$0.additionalData] Additional data to include in the request.
 * @param [$0.allowedTypes]   Array with the types of media that can be uploaded, if unset all types are allowed.
 */
function addItems({
  files,
  onChange,
  onSuccess,
  onError,
  onBatchSuccess,
  additionalData,
  allowedTypes
}) {
  return async ({
    select,
    dispatch
  }) => {
    const batchId = (0, _uuid.v4)();
    for (const file of files) {
      /*
       Check if the caller (e.g. a block) supports this mime type.
       Special case for file types such as HEIC which will be converted before upload anyway.
       Another check will be done before upload.
      */
      try {
        (0, _validateMimeType.validateMimeType)(file, allowedTypes);
        (0, _validateMimeTypeForUser.validateMimeTypeForUser)(file, select.getSettings().allowedMimeTypes);
      } catch (error) {
        onError?.(error);
        continue;
      }
      try {
        (0, _validateFileSize.validateFileSize)(file, select.getSettings().maxUploadFileSize);
      } catch (error) {
        onError?.(error);
        continue;
      }
      dispatch.addItem({
        file,
        batchId,
        onChange,
        onSuccess,
        onBatchSuccess,
        onError,
        additionalData
      });
    }
  };
}

/**
 * Cancels an item in the queue based on an error.
 *
 * @param id     Item ID.
 * @param error  Error instance.
 * @param silent Whether to cancel the item silently,
 *               without invoking its `onError` callback.
 */
function cancelItem(id, error, silent = false) {
  return async ({
    select,
    dispatch
  }) => {
    const item = select.getItem(id);
    if (!item) {
      /*
       * Do nothing if item has already been removed.
       * This can happen if an upload is cancelled manually
       * while transcoding with vips is still in progress.
       * Then, cancelItem() is once invoked manually and once
       * by the error handler in optimizeImageItem().
       */
      return;
    }
    item.abortController?.abort();
    if (!silent) {
      const {
        onError
      } = item;
      onError?.(error !== null && error !== void 0 ? error : new Error('Upload cancelled'));
      if (!onError && error) {
        // TODO: Find better way to surface errors with sideloads etc.
        // eslint-disable-next-line no-console -- Deliberately log errors here.
        console.error('Upload cancelled', error);
      }
    }
    dispatch({
      type: _types.Type.Cancel,
      id,
      error
    });
    dispatch.removeItem(id);
    dispatch.revokeBlobUrls(id);

    // All items of this batch were cancelled or finished.
    if (item.batchId && select.isBatchUploaded(item.batchId)) {
      item.onBatchSuccess?.();
    }
  };
}
//# sourceMappingURL=actions.js.map