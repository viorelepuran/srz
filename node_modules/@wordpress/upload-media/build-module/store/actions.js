/**
 * External dependencies
 */
import { v4 as uuidv4 } from 'uuid';

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

import { Type } from './types';
import { validateMimeType } from '../validate-mime-type';
import { validateMimeTypeForUser } from '../validate-mime-type-for-user';
import { validateFileSize } from '../validate-file-size';
/**
 * Adds a new item to the upload queue.
 *
 * @param $0
 * @param $0.files            Files
 * @param [$0.onChange]       Function called each time a file or a temporary representation of the file is available.
 * @param [$0.onSuccess]      Function called after the file is uploaded.
 * @param [$0.onBatchSuccess] Function called after a batch of files is uploaded.
 * @param [$0.onError]        Function called when an error happens.
 * @param [$0.additionalData] Additional data to include in the request.
 * @param [$0.allowedTypes]   Array with the types of media that can be uploaded, if unset all types are allowed.
 */
export function addItems({
  files,
  onChange,
  onSuccess,
  onError,
  onBatchSuccess,
  additionalData,
  allowedTypes
}) {
  return async ({
    select,
    dispatch
  }) => {
    const batchId = uuidv4();
    for (const file of files) {
      /*
       Check if the caller (e.g. a block) supports this mime type.
       Special case for file types such as HEIC which will be converted before upload anyway.
       Another check will be done before upload.
      */
      try {
        validateMimeType(file, allowedTypes);
        validateMimeTypeForUser(file, select.getSettings().allowedMimeTypes);
      } catch (error) {
        onError?.(error);
        continue;
      }
      try {
        validateFileSize(file, select.getSettings().maxUploadFileSize);
      } catch (error) {
        onError?.(error);
        continue;
      }
      dispatch.addItem({
        file,
        batchId,
        onChange,
        onSuccess,
        onBatchSuccess,
        onError,
        additionalData
      });
    }
  };
}

/**
 * Cancels an item in the queue based on an error.
 *
 * @param id     Item ID.
 * @param error  Error instance.
 * @param silent Whether to cancel the item silently,
 *               without invoking its `onError` callback.
 */
export function cancelItem(id, error, silent = false) {
  return async ({
    select,
    dispatch
  }) => {
    const item = select.getItem(id);
    if (!item) {
      /*
       * Do nothing if item has already been removed.
       * This can happen if an upload is cancelled manually
       * while transcoding with vips is still in progress.
       * Then, cancelItem() is once invoked manually and once
       * by the error handler in optimizeImageItem().
       */
      return;
    }
    item.abortController?.abort();
    if (!silent) {
      const {
        onError
      } = item;
      onError?.(error !== null && error !== void 0 ? error : new Error('Upload cancelled'));
      if (!onError && error) {
        // TODO: Find better way to surface errors with sideloads etc.
        // eslint-disable-next-line no-console -- Deliberately log errors here.
        console.error('Upload cancelled', error);
      }
    }
    dispatch({
      type: Type.Cancel,
      id,
      error
    });
    dispatch.removeItem(id);
    dispatch.revokeBlobUrls(id);

    // All items of this batch were cancelled or finished.
    if (item.batchId && select.isBatchUploaded(item.batchId)) {
      item.onBatchSuccess?.();
    }
  };
}
//# sourceMappingURL=actions.js.map