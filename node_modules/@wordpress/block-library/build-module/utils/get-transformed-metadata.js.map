{"version":3,"names":["getBlockType","getTransformedMetadata","metadata","newBlockName","bindingsCallback","supports","BLOCK_BINDINGS_SUPPORTED_BLOCKS","transformSupportedProps","includes","push","renaming","length","newMetadata","Object","entries","reduce","obj","prop","value","keys","undefined"],"sources":["@wordpress/block-library/src/utils/get-transformed-metadata.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { getBlockType } from '@wordpress/blocks';\n\n/**\n * Transform the metadata attribute with only the values and bindings specified by each transform.\n * Returns `undefined` if the input metadata is falsy.\n *\n * @param {Object}   metadata         Original metadata attribute from the block that is being transformed.\n * @param {Object}   newBlockName     Name of the final block after the transformation.\n * @param {Function} bindingsCallback Optional callback to transform the `bindings` property object.\n * @return {Object|undefined} New metadata object only with the relevant properties.\n */\nexport function getTransformedMetadata(\n\tmetadata,\n\tnewBlockName,\n\tbindingsCallback\n) {\n\tif ( ! metadata ) {\n\t\treturn;\n\t}\n\tconst { supports } = getBlockType( newBlockName );\n\t// Fixed until an opt-in mechanism is implemented.\n\tconst BLOCK_BINDINGS_SUPPORTED_BLOCKS = [\n\t\t'core/paragraph',\n\t\t'core/heading',\n\t\t'core/image',\n\t\t'core/button',\n\t];\n\t// The metadata properties that should be preserved after the transform.\n\tconst transformSupportedProps = [];\n\t// If it support bindings, and there is a transform bindings callback, add the `id` and `bindings` properties.\n\tif (\n\t\tBLOCK_BINDINGS_SUPPORTED_BLOCKS.includes( newBlockName ) &&\n\t\tbindingsCallback\n\t) {\n\t\ttransformSupportedProps.push( 'id', 'bindings' );\n\t}\n\t// If it support block naming (true by default), add the `name` property.\n\tif ( supports.renaming !== false ) {\n\t\ttransformSupportedProps.push( 'name' );\n\t}\n\n\t// Return early if no supported properties.\n\tif ( ! transformSupportedProps.length ) {\n\t\treturn;\n\t}\n\n\tconst newMetadata = Object.entries( metadata ).reduce(\n\t\t( obj, [ prop, value ] ) => {\n\t\t\t// If prop is not supported, don't add it to the new metadata object.\n\t\t\tif ( ! transformSupportedProps.includes( prop ) ) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tobj[ prop ] =\n\t\t\t\tprop === 'bindings' ? bindingsCallback( value ) : value;\n\t\t\treturn obj;\n\t\t},\n\t\t{}\n\t);\n\n\t// Return undefined if object is empty.\n\treturn Object.keys( newMetadata ).length ? newMetadata : undefined;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,YAAY,QAAQ,mBAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,sBAAsBA,CACrCC,QAAQ,EACRC,YAAY,EACZC,gBAAgB,EACf;EACD,IAAK,CAAEF,QAAQ,EAAG;IACjB;EACD;EACA,MAAM;IAAEG;EAAS,CAAC,GAAGL,YAAY,CAAEG,YAAa,CAAC;EACjD;EACA,MAAMG,+BAA+B,GAAG,CACvC,gBAAgB,EAChB,cAAc,EACd,YAAY,EACZ,aAAa,CACb;EACD;EACA,MAAMC,uBAAuB,GAAG,EAAE;EAClC;EACA,IACCD,+BAA+B,CAACE,QAAQ,CAAEL,YAAa,CAAC,IACxDC,gBAAgB,EACf;IACDG,uBAAuB,CAACE,IAAI,CAAE,IAAI,EAAE,UAAW,CAAC;EACjD;EACA;EACA,IAAKJ,QAAQ,CAACK,QAAQ,KAAK,KAAK,EAAG;IAClCH,uBAAuB,CAACE,IAAI,CAAE,MAAO,CAAC;EACvC;;EAEA;EACA,IAAK,CAAEF,uBAAuB,CAACI,MAAM,EAAG;IACvC;EACD;EAEA,MAAMC,WAAW,GAAGC,MAAM,CAACC,OAAO,CAAEZ,QAAS,CAAC,CAACa,MAAM,CACpD,CAAEC,GAAG,EAAE,CAAEC,IAAI,EAAEC,KAAK,CAAE,KAAM;IAC3B;IACA,IAAK,CAAEX,uBAAuB,CAACC,QAAQ,CAAES,IAAK,CAAC,EAAG;MACjD,OAAOD,GAAG;IACX;IACAA,GAAG,CAAEC,IAAI,CAAE,GACVA,IAAI,KAAK,UAAU,GAAGb,gBAAgB,CAAEc,KAAM,CAAC,GAAGA,KAAK;IACxD,OAAOF,GAAG;EACX,CAAC,EACD,CAAC,CACF,CAAC;;EAED;EACA,OAAOH,MAAM,CAACM,IAAI,CAAEP,WAAY,CAAC,CAACD,MAAM,GAAGC,WAAW,GAAGQ,SAAS;AACnE","ignoreList":[]}