{"version":3,"names":["linearToNestedHeadingList","headingList","nestedHeadingList","forEach","heading","key","content","level","endOfSlice","length","i","push","children","slice"],"sources":["@wordpress/block-library/src/table-of-contents/utils.ts"],"sourcesContent":["export interface HeadingData {\n\t/** The plain text content of the heading. */\n\tcontent: string;\n\t/** The heading level. */\n\tlevel: number;\n\t/** Link to the heading. */\n\tlink: string;\n}\n\nexport interface NestedHeadingData {\n\t/** The heading content, level, and link. */\n\theading: HeadingData;\n\t/** The sub-headings of this heading, if any. */\n\tchildren: NestedHeadingData[] | null;\n}\n\n/**\n * Takes a flat list of heading parameters and nests them based on each header's\n * immediate parent's level.\n *\n * @param headingList The flat list of headings to nest.\n *\n * @return The nested list of headings.\n */\nexport function linearToNestedHeadingList(\n\theadingList: HeadingData[]\n): NestedHeadingData[] {\n\tconst nestedHeadingList: NestedHeadingData[] = [];\n\n\theadingList.forEach( ( heading, key ) => {\n\t\tif ( heading.content === '' ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure we are only working with the same level as the first iteration in our set.\n\t\tif ( heading.level === headingList[ 0 ].level ) {\n\t\t\t// Check that the next iteration will return a value.\n\t\t\t// If it does and the next level is greater than the current level,\n\t\t\t// the next iteration becomes a child of the current iteration.\n\t\t\tif ( headingList[ key + 1 ]?.level > heading.level ) {\n\t\t\t\t// We must calculate the last index before the next iteration that\n\t\t\t\t// has the same level (siblings). We then use this index to slice\n\t\t\t\t// the array for use in recursion. This prevents duplicate nodes.\n\t\t\t\tlet endOfSlice = headingList.length;\n\t\t\t\tfor ( let i = key + 1; i < headingList.length; i++ ) {\n\t\t\t\t\tif ( headingList[ i ].level === heading.level ) {\n\t\t\t\t\t\tendOfSlice = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We found a child node: Push a new node onto the return array\n\t\t\t\t// with children.\n\t\t\t\tnestedHeadingList.push( {\n\t\t\t\t\theading,\n\t\t\t\t\tchildren: linearToNestedHeadingList(\n\t\t\t\t\t\theadingList.slice( key + 1, endOfSlice )\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t// No child node: Push a new node onto the return array.\n\t\t\t\tnestedHeadingList.push( {\n\t\t\t\t\theading,\n\t\t\t\t\tchildren: null,\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t} );\n\n\treturn nestedHeadingList;\n}\n"],"mappings":"AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,yBAAyBA,CACxCC,WAA0B,EACJ;EACtB,MAAMC,iBAAsC,GAAG,EAAE;EAEjDD,WAAW,CAACE,OAAO,CAAE,CAAEC,OAAO,EAAEC,GAAG,KAAM;IACxC,IAAKD,OAAO,CAACE,OAAO,KAAK,EAAE,EAAG;MAC7B;IACD;;IAEA;IACA,IAAKF,OAAO,CAACG,KAAK,KAAKN,WAAW,CAAE,CAAC,CAAE,CAACM,KAAK,EAAG;MAC/C;MACA;MACA;MACA,IAAKN,WAAW,CAAEI,GAAG,GAAG,CAAC,CAAE,EAAEE,KAAK,GAAGH,OAAO,CAACG,KAAK,EAAG;QACpD;QACA;QACA;QACA,IAAIC,UAAU,GAAGP,WAAW,CAACQ,MAAM;QACnC,KAAM,IAAIC,CAAC,GAAGL,GAAG,GAAG,CAAC,EAAEK,CAAC,GAAGT,WAAW,CAACQ,MAAM,EAAEC,CAAC,EAAE,EAAG;UACpD,IAAKT,WAAW,CAAES,CAAC,CAAE,CAACH,KAAK,KAAKH,OAAO,CAACG,KAAK,EAAG;YAC/CC,UAAU,GAAGE,CAAC;YACd;UACD;QACD;;QAEA;QACA;QACAR,iBAAiB,CAACS,IAAI,CAAE;UACvBP,OAAO;UACPQ,QAAQ,EAAEZ,yBAAyB,CAClCC,WAAW,CAACY,KAAK,CAAER,GAAG,GAAG,CAAC,EAAEG,UAAW,CACxC;QACD,CAAE,CAAC;MACJ,CAAC,MAAM;QACN;QACAN,iBAAiB,CAACS,IAAI,CAAE;UACvBP,OAAO;UACPQ,QAAQ,EAAE;QACX,CAAE,CAAC;MACJ;IACD;EACD,CAAE,CAAC;EAEH,OAAOV,iBAAiB;AACzB","ignoreList":[]}