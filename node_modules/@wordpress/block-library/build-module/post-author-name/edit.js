/**
 * External dependencies
 */
import clsx from 'clsx';

/**
 * WordPress dependencies
 */
import { AlignmentControl, BlockControls, InspectorControls, useBlockProps } from '@wordpress/block-editor';
import { useSelect } from '@wordpress/data';
import { __, sprintf } from '@wordpress/i18n';
import { store as coreStore } from '@wordpress/core-data';
import { ToggleControl, __experimentalToolsPanel as ToolsPanel, __experimentalToolsPanelItem as ToolsPanelItem } from '@wordpress/components';

/**
 * Internal dependencies
 */
import { useToolsPanelDropdownMenuProps } from '../utils/hooks';
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
function PostAuthorNameEdit({
  context: {
    postType,
    postId
  },
  attributes: {
    textAlign,
    isLink,
    linkTarget
  },
  setAttributes
}) {
  const {
    authorName,
    supportsAuthor
  } = useSelect(select => {
    var _getPostType$supports;
    const {
      getEditedEntityRecord,
      getUser,
      getPostType
    } = select(coreStore);
    const _authorId = getEditedEntityRecord('postType', postType, postId)?.author;
    return {
      authorName: _authorId ? getUser(_authorId) : null,
      supportsAuthor: (_getPostType$supports = getPostType(postType)?.supports?.author) !== null && _getPostType$supports !== void 0 ? _getPostType$supports : false
    };
  }, [postType, postId]);
  const blockProps = useBlockProps({
    className: clsx({
      [`has-text-align-${textAlign}`]: textAlign
    })
  });
  const displayName = authorName?.name || __('Author Name');
  const displayAuthor = isLink ? /*#__PURE__*/_jsx("a", {
    href: "#author-pseudo-link",
    onClick: event => event.preventDefault(),
    className: "wp-block-post-author-name__link",
    children: displayName
  }) : displayName;
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  return /*#__PURE__*/_jsxs(_Fragment, {
    children: [/*#__PURE__*/_jsx(BlockControls, {
      group: "block",
      children: /*#__PURE__*/_jsx(AlignmentControl, {
        value: textAlign,
        onChange: nextAlign => {
          setAttributes({
            textAlign: nextAlign
          });
        }
      })
    }), /*#__PURE__*/_jsx(InspectorControls, {
      children: /*#__PURE__*/_jsxs(ToolsPanel, {
        label: __('Settings'),
        resetAll: () => {
          setAttributes({
            isLink: false,
            linkTarget: '_self'
          });
        },
        dropdownMenuProps: dropdownMenuProps,
        children: [/*#__PURE__*/_jsx(ToolsPanelItem, {
          label: __('Link to author archive'),
          isShownByDefault: true,
          hasValue: () => isLink,
          onDeselect: () => setAttributes({
            isLink: false
          }),
          children: /*#__PURE__*/_jsx(ToggleControl, {
            __nextHasNoMarginBottom: true,
            label: __('Link to author archive'),
            onChange: () => setAttributes({
              isLink: !isLink
            }),
            checked: isLink
          })
        }), isLink && /*#__PURE__*/_jsx(ToolsPanelItem, {
          label: __('Open in new tab'),
          isShownByDefault: true,
          hasValue: () => linkTarget !== '_self',
          onDeselect: () => setAttributes({
            linkTarget: '_self'
          }),
          children: /*#__PURE__*/_jsx(ToggleControl, {
            __nextHasNoMarginBottom: true,
            label: __('Open in new tab'),
            onChange: value => setAttributes({
              linkTarget: value ? '_blank' : '_self'
            }),
            checked: linkTarget === '_blank'
          })
        })]
      })
    }), /*#__PURE__*/_jsx("div", {
      ...blockProps,
      children: !supportsAuthor && postType !== undefined ? sprintf(
      // translators: %s: Name of the post type e.g: "post".
      __('This post type (%s) does not support the author.'), postType) : displayAuthor
    })]
  });
}
export default PostAuthorNameEdit;
//# sourceMappingURL=edit.js.map