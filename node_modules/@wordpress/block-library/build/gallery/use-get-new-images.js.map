{"version":3,"names":["_element","require","useGetNewImages","images","imageData","currentImages","setCurrentImages","useState","useMemo","getNewImages","imagesUpdated","newCurrentImages","filter","currentImg","find","img","clientId","length","forEach","image","fromSavedContent","currentImage","id","push","newImages"],"sources":["@wordpress/block-library/src/gallery/use-get-new-images.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useMemo, useState } from '@wordpress/element';\n\n/**\n * Keeps track of images already in the gallery to allow new innerBlocks to be identified. This\n * is required so default gallery attributes can be applied without overwriting any custom\n * attributes applied to existing images.\n *\n * @param {Array} images    Basic image block data taken from current gallery innerBlock\n * @param {Array} imageData The related image data for each of the current gallery images.\n *\n * @return {Array} An array of any new images that have been added to the gallery.\n */\nexport default function useGetNewImages( images, imageData ) {\n\tconst [ currentImages, setCurrentImages ] = useState( [] );\n\n\treturn useMemo( () => getNewImages(), [ images, imageData ] );\n\n\tfunction getNewImages() {\n\t\tlet imagesUpdated = false;\n\n\t\t// First lets check if any images have been deleted.\n\t\tconst newCurrentImages = currentImages.filter( ( currentImg ) =>\n\t\t\timages.find( ( img ) => {\n\t\t\t\treturn currentImg.clientId === img.clientId;\n\t\t\t} )\n\t\t);\n\n\t\tif ( newCurrentImages.length < currentImages.length ) {\n\t\t\timagesUpdated = true;\n\t\t}\n\n\t\t// Now lets see if we have any images hydrated from saved content and if so\n\t\t// add them to currentImages state.\n\t\timages.forEach( ( image ) => {\n\t\t\tif (\n\t\t\t\timage.fromSavedContent &&\n\t\t\t\t! newCurrentImages.find(\n\t\t\t\t\t( currentImage ) => currentImage.id === image.id\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\timagesUpdated = true;\n\t\t\t\tnewCurrentImages.push( image );\n\t\t\t}\n\t\t} );\n\n\t\t// Now check for any new images that have been added to InnerBlocks and for which\n\t\t// we have the imageData we need for setting default block attributes.\n\t\tconst newImages = images.filter(\n\t\t\t( image ) =>\n\t\t\t\t! newCurrentImages.find(\n\t\t\t\t\t( currentImage ) =>\n\t\t\t\t\t\timage.clientId &&\n\t\t\t\t\t\tcurrentImage.clientId === image.clientId\n\t\t\t\t) &&\n\t\t\t\timageData?.find( ( img ) => img.id === image.id ) &&\n\t\t\t\t! image.fromSavedContent\n\t\t);\n\n\t\tif ( imagesUpdated || newImages?.length > 0 ) {\n\t\t\tsetCurrentImages( [ ...newCurrentImages, ...newImages ] );\n\t\t}\n\n\t\treturn newImages.length > 0 ? newImages : null;\n\t}\n}\n"],"mappings":";;;;;;AAGA,IAAAA,QAAA,GAAAC,OAAA;AAHA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASC,eAAeA,CAAEC,MAAM,EAAEC,SAAS,EAAG;EAC5D,MAAM,CAAEC,aAAa,EAAEC,gBAAgB,CAAE,GAAG,IAAAC,iBAAQ,EAAE,EAAG,CAAC;EAE1D,OAAO,IAAAC,gBAAO,EAAE,MAAMC,YAAY,CAAC,CAAC,EAAE,CAAEN,MAAM,EAAEC,SAAS,CAAG,CAAC;EAE7D,SAASK,YAAYA,CAAA,EAAG;IACvB,IAAIC,aAAa,GAAG,KAAK;;IAEzB;IACA,MAAMC,gBAAgB,GAAGN,aAAa,CAACO,MAAM,CAAIC,UAAU,IAC1DV,MAAM,CAACW,IAAI,CAAIC,GAAG,IAAM;MACvB,OAAOF,UAAU,CAACG,QAAQ,KAAKD,GAAG,CAACC,QAAQ;IAC5C,CAAE,CACH,CAAC;IAED,IAAKL,gBAAgB,CAACM,MAAM,GAAGZ,aAAa,CAACY,MAAM,EAAG;MACrDP,aAAa,GAAG,IAAI;IACrB;;IAEA;IACA;IACAP,MAAM,CAACe,OAAO,CAAIC,KAAK,IAAM;MAC5B,IACCA,KAAK,CAACC,gBAAgB,IACtB,CAAET,gBAAgB,CAACG,IAAI,CACpBO,YAAY,IAAMA,YAAY,CAACC,EAAE,KAAKH,KAAK,CAACG,EAC/C,CAAC,EACA;QACDZ,aAAa,GAAG,IAAI;QACpBC,gBAAgB,CAACY,IAAI,CAAEJ,KAAM,CAAC;MAC/B;IACD,CAAE,CAAC;;IAEH;IACA;IACA,MAAMK,SAAS,GAAGrB,MAAM,CAACS,MAAM,CAC5BO,KAAK,IACN,CAAER,gBAAgB,CAACG,IAAI,CACpBO,YAAY,IACbF,KAAK,CAACH,QAAQ,IACdK,YAAY,CAACL,QAAQ,KAAKG,KAAK,CAACH,QAClC,CAAC,IACDZ,SAAS,EAAEU,IAAI,CAAIC,GAAG,IAAMA,GAAG,CAACO,EAAE,KAAKH,KAAK,CAACG,EAAG,CAAC,IACjD,CAAEH,KAAK,CAACC,gBACV,CAAC;IAED,IAAKV,aAAa,IAAIc,SAAS,EAAEP,MAAM,GAAG,CAAC,EAAG;MAC7CX,gBAAgB,CAAE,CAAE,GAAGK,gBAAgB,EAAE,GAAGa,SAAS,CAAG,CAAC;IAC1D;IAEA,OAAOA,SAAS,CAACP,MAAM,GAAG,CAAC,GAAGO,SAAS,GAAG,IAAI;EAC/C;AACD","ignoreList":[]}