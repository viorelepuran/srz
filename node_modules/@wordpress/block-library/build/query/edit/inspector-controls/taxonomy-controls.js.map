{"version":3,"names":["_components","require","_data","_coreData","_element","_compose","_htmlEntities","_utils","_jsxRuntime","EMPTY_ARRAY","BASE_QUERY","order","_fields","context","getTermIdByTermValue","terms","termValue","termId","id","find","term","name","termValueLower","toLocaleLowerCase","TaxonomyControls","onChange","query","postType","taxQuery","taxonomies","useTaxonomies","length","jsx","__experimentalVStack","spacing","children","map","taxonomy","termIds","slug","handleChange","newTermIds","TaxonomyItem","search","setSearch","useState","value","setValue","suggestions","setSuggestions","debouncedSearch","useDebounce","searchResults","searchHasResolved","useSelect","select","getEntityRecords","hasFinishedResolution","coreStore","selectorArgs","orderby","exclude","per_page","existingTerms","include","useEffect","sanitizedValue","reduce","accumulator","entity","push","result","onTermsChange","newTermValues","Set","add","Array","from","className","FormTokenField","label","onInputChange","displayTransform","decodeEntities","__experimentalShowHowTo","__nextHasNoMarginBottom","__next40pxDefaultSize"],"sources":["@wordpress/block-library/src/query/edit/inspector-controls/taxonomy-controls.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport {\n\tFormTokenField,\n\t__experimentalVStack as VStack,\n} from '@wordpress/components';\nimport { useSelect } from '@wordpress/data';\nimport { store as coreStore } from '@wordpress/core-data';\nimport { useState, useEffect } from '@wordpress/element';\nimport { useDebounce } from '@wordpress/compose';\nimport { decodeEntities } from '@wordpress/html-entities';\n\n/**\n * Internal dependencies\n */\nimport { useTaxonomies } from '../../utils';\n\nconst EMPTY_ARRAY = [];\nconst BASE_QUERY = {\n\torder: 'asc',\n\t_fields: 'id,name',\n\tcontext: 'view',\n};\n\n// Helper function to get the term id based on user input in terms `FormTokenField`.\nconst getTermIdByTermValue = ( terms, termValue ) => {\n\t// First we check for exact match by `term.id` or case sensitive `term.name` match.\n\tconst termId =\n\t\ttermValue?.id || terms?.find( ( term ) => term.name === termValue )?.id;\n\tif ( termId ) {\n\t\treturn termId;\n\t}\n\n\t/**\n\t * Here we make an extra check for entered terms in a non case sensitive way,\n\t * to match user expectations, due to `FormTokenField` behaviour that shows\n\t * suggestions which are case insensitive.\n\t *\n\t * Although WP tries to discourage users to add terms with the same name (case insensitive),\n\t * it's still possible if you manually change the name, as long as the terms have different slugs.\n\t * In this edge case we always apply the first match from the terms list.\n\t */\n\tconst termValueLower = termValue.toLocaleLowerCase();\n\treturn terms?.find(\n\t\t( term ) => term.name.toLocaleLowerCase() === termValueLower\n\t)?.id;\n};\n\nexport function TaxonomyControls( { onChange, query } ) {\n\tconst { postType, taxQuery } = query;\n\n\tconst taxonomies = useTaxonomies( postType );\n\tif ( ! taxonomies || taxonomies.length === 0 ) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<VStack spacing={ 4 }>\n\t\t\t{ taxonomies.map( ( taxonomy ) => {\n\t\t\t\tconst termIds = taxQuery?.[ taxonomy.slug ] || [];\n\t\t\t\tconst handleChange = ( newTermIds ) =>\n\t\t\t\t\tonChange( {\n\t\t\t\t\t\ttaxQuery: {\n\t\t\t\t\t\t\t...taxQuery,\n\t\t\t\t\t\t\t[ taxonomy.slug ]: newTermIds,\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\treturn (\n\t\t\t\t\t<TaxonomyItem\n\t\t\t\t\t\tkey={ taxonomy.slug }\n\t\t\t\t\t\ttaxonomy={ taxonomy }\n\t\t\t\t\t\ttermIds={ termIds }\n\t\t\t\t\t\tonChange={ handleChange }\n\t\t\t\t\t/>\n\t\t\t\t);\n\t\t\t} ) }\n\t\t</VStack>\n\t);\n}\n\n/**\n * Renders a `FormTokenField` for a given taxonomy.\n *\n * @param {Object}   props          The props for the component.\n * @param {Object}   props.taxonomy The taxonomy object.\n * @param {number[]} props.termIds  An array with the block's term ids for the given taxonomy.\n * @param {Function} props.onChange Callback `onChange` function.\n * @return {JSX.Element} The rendered component.\n */\nfunction TaxonomyItem( { taxonomy, termIds, onChange } ) {\n\tconst [ search, setSearch ] = useState( '' );\n\tconst [ value, setValue ] = useState( EMPTY_ARRAY );\n\tconst [ suggestions, setSuggestions ] = useState( EMPTY_ARRAY );\n\tconst debouncedSearch = useDebounce( setSearch, 250 );\n\tconst { searchResults, searchHasResolved } = useSelect(\n\t\t( select ) => {\n\t\t\tif ( ! search ) {\n\t\t\t\treturn { searchResults: EMPTY_ARRAY, searchHasResolved: true };\n\t\t\t}\n\t\t\tconst { getEntityRecords, hasFinishedResolution } =\n\t\t\t\tselect( coreStore );\n\t\t\tconst selectorArgs = [\n\t\t\t\t'taxonomy',\n\t\t\t\ttaxonomy.slug,\n\t\t\t\t{\n\t\t\t\t\t...BASE_QUERY,\n\t\t\t\t\tsearch,\n\t\t\t\t\torderby: 'name',\n\t\t\t\t\texclude: termIds,\n\t\t\t\t\tper_page: 20,\n\t\t\t\t},\n\t\t\t];\n\t\t\treturn {\n\t\t\t\tsearchResults: getEntityRecords( ...selectorArgs ),\n\t\t\t\tsearchHasResolved: hasFinishedResolution(\n\t\t\t\t\t'getEntityRecords',\n\t\t\t\t\tselectorArgs\n\t\t\t\t),\n\t\t\t};\n\t\t},\n\t\t[ search, taxonomy.slug, termIds ]\n\t);\n\t// `existingTerms` are the ones fetched from the API and their type is `{ id: number; name: string }`.\n\t// They are used to extract the terms' names to populate the `FormTokenField` properly\n\t// and to sanitize the provided `termIds`, by setting only the ones that exist.\n\tconst existingTerms = useSelect(\n\t\t( select ) => {\n\t\t\tif ( ! termIds?.length ) {\n\t\t\t\treturn EMPTY_ARRAY;\n\t\t\t}\n\t\t\tconst { getEntityRecords } = select( coreStore );\n\t\t\treturn getEntityRecords( 'taxonomy', taxonomy.slug, {\n\t\t\t\t...BASE_QUERY,\n\t\t\t\tinclude: termIds,\n\t\t\t\tper_page: termIds.length,\n\t\t\t} );\n\t\t},\n\t\t[ taxonomy.slug, termIds ]\n\t);\n\t// Update the `value` state only after the selectors are resolved\n\t// to avoid emptying the input when we're changing terms.\n\tuseEffect( () => {\n\t\tif ( ! termIds?.length ) {\n\t\t\tsetValue( EMPTY_ARRAY );\n\t\t}\n\t\tif ( ! existingTerms?.length ) {\n\t\t\treturn;\n\t\t}\n\t\t// Returns only the existing entity ids. This prevents the component\n\t\t// from crashing in the editor, when non existing ids are provided.\n\t\tconst sanitizedValue = termIds.reduce( ( accumulator, id ) => {\n\t\t\tconst entity = existingTerms.find( ( term ) => term.id === id );\n\t\t\tif ( entity ) {\n\t\t\t\taccumulator.push( {\n\t\t\t\t\tid,\n\t\t\t\t\tvalue: entity.name,\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn accumulator;\n\t\t}, [] );\n\t\tsetValue( sanitizedValue );\n\t}, [ termIds, existingTerms ] );\n\t// Update suggestions only when the query has resolved.\n\tuseEffect( () => {\n\t\tif ( ! searchHasResolved ) {\n\t\t\treturn;\n\t\t}\n\t\tsetSuggestions( searchResults.map( ( result ) => result.name ) );\n\t}, [ searchResults, searchHasResolved ] );\n\tconst onTermsChange = ( newTermValues ) => {\n\t\tconst newTermIds = new Set();\n\t\tfor ( const termValue of newTermValues ) {\n\t\t\tconst termId = getTermIdByTermValue( searchResults, termValue );\n\t\t\tif ( termId ) {\n\t\t\t\tnewTermIds.add( termId );\n\t\t\t}\n\t\t}\n\t\tsetSuggestions( EMPTY_ARRAY );\n\t\tonChange( Array.from( newTermIds ) );\n\t};\n\treturn (\n\t\t<div className=\"block-library-query-inspector__taxonomy-control\">\n\t\t\t<FormTokenField\n\t\t\t\tlabel={ taxonomy.name }\n\t\t\t\tvalue={ value }\n\t\t\t\tonInputChange={ debouncedSearch }\n\t\t\t\tsuggestions={ suggestions }\n\t\t\t\tdisplayTransform={ decodeEntities }\n\t\t\t\tonChange={ onTermsChange }\n\t\t\t\t__experimentalShowHowTo={ false }\n\t\t\t\t__nextHasNoMarginBottom\n\t\t\t\t__next40pxDefaultSize\n\t\t\t/>\n\t\t</div>\n\t);\n}\n"],"mappings":"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","ignoreList":[]}