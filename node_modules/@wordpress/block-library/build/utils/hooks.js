"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCanEditEntity = useCanEditEntity;
exports.useToolsPanelDropdownMenuProps = useToolsPanelDropdownMenuProps;
exports.useUploadMediaFromBlobURL = useUploadMediaFromBlobURL;
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _blob = require("@wordpress/blob");
var _blockEditor = require("@wordpress/block-editor");
var _coreData = require("@wordpress/core-data");
var _compose = require("@wordpress/compose");
/**
 * WordPress dependencies
 */

/**
 * Returns whether the current user can edit the given entity.
 *
 * @param {string} kind     Entity kind.
 * @param {string} name     Entity name.
 * @param {string} recordId Record's id.
 */
function useCanEditEntity(kind, name, recordId) {
  return (0, _data.useSelect)(select => select(_coreData.store).canUser('update', {
    kind,
    name,
    id: recordId
  }), [kind, name, recordId]);
}

/**
 * Handles uploading a media file from a blob URL on mount.
 *
 * @param {Object}   args              Upload media arguments.
 * @param {string}   args.url          Blob URL.
 * @param {?Array}   args.allowedTypes Array of allowed media types.
 * @param {Function} args.onChange     Function called when the media is uploaded.
 * @param {Function} args.onError      Function called when an error happens.
 */
function useUploadMediaFromBlobURL(args = {}) {
  const latestArgsRef = (0, _element.useRef)(args);
  const hasUploadStartedRef = (0, _element.useRef)(false);
  const {
    getSettings
  } = (0, _data.useSelect)(_blockEditor.store);
  (0, _element.useLayoutEffect)(() => {
    latestArgsRef.current = args;
  });
  (0, _element.useEffect)(() => {
    // Uploading is a special effect that can't be canceled via the cleanup method.
    // The extra check avoids duplicate uploads in development mode (React.StrictMode).
    if (hasUploadStartedRef.current) {
      return;
    }
    if (!latestArgsRef.current.url || !(0, _blob.isBlobURL)(latestArgsRef.current.url)) {
      return;
    }
    const file = (0, _blob.getBlobByURL)(latestArgsRef.current.url);
    if (!file) {
      return;
    }
    const {
      url,
      allowedTypes,
      onChange,
      onError
    } = latestArgsRef.current;
    const {
      mediaUpload
    } = getSettings();
    hasUploadStartedRef.current = true;
    mediaUpload({
      filesList: [file],
      allowedTypes,
      onFileChange: ([media]) => {
        if ((0, _blob.isBlobURL)(media?.url)) {
          return;
        }
        (0, _blob.revokeBlobURL)(url);
        onChange(media);
        hasUploadStartedRef.current = false;
      },
      onError: message => {
        (0, _blob.revokeBlobURL)(url);
        onError(message);
        hasUploadStartedRef.current = false;
      }
    });
  }, [getSettings]);
}
function useToolsPanelDropdownMenuProps() {
  const isMobile = (0, _compose.useViewportMatch)('medium', '<');
  return !isMobile ? {
    popoverProps: {
      placement: 'left-start',
      // For non-mobile, inner sidebar width (248px) - button width (24px) - border (1px) + padding (16px) + spacing (20px)
      offset: 259
    }
  } : {};
}
//# sourceMappingURL=hooks.js.map