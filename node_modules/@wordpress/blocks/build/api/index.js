"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "__EXPERIMENTAL_ELEMENTS", {
  enumerable: true,
  get: function () {
    return _constants.__EXPERIMENTAL_ELEMENTS;
  }
});
Object.defineProperty(exports, "__EXPERIMENTAL_PATHS_WITH_OVERRIDE", {
  enumerable: true,
  get: function () {
    return _constants.__EXPERIMENTAL_PATHS_WITH_OVERRIDE;
  }
});
Object.defineProperty(exports, "__EXPERIMENTAL_STYLE_PROPERTY", {
  enumerable: true,
  get: function () {
    return _constants.__EXPERIMENTAL_STYLE_PROPERTY;
  }
});
Object.defineProperty(exports, "__experimentalCloneSanitizedBlock", {
  enumerable: true,
  get: function () {
    return _factory.__experimentalCloneSanitizedBlock;
  }
});
Object.defineProperty(exports, "__experimentalGetAccessibleBlockLabel", {
  enumerable: true,
  get: function () {
    return _utils.getAccessibleBlockLabel;
  }
});
Object.defineProperty(exports, "__experimentalGetBlockAttributesNamesByRole", {
  enumerable: true,
  get: function () {
    return _utils.__experimentalGetBlockAttributesNamesByRole;
  }
});
Object.defineProperty(exports, "__experimentalGetBlockLabel", {
  enumerable: true,
  get: function () {
    return _utils.getBlockLabel;
  }
});
Object.defineProperty(exports, "__experimentalSanitizeBlockAttributes", {
  enumerable: true,
  get: function () {
    return _utils.__experimentalSanitizeBlockAttributes;
  }
});
Object.defineProperty(exports, "__unstableGetBlockProps", {
  enumerable: true,
  get: function () {
    return _serializer.getBlockProps;
  }
});
Object.defineProperty(exports, "__unstableGetInnerBlocksProps", {
  enumerable: true,
  get: function () {
    return _serializer.getInnerBlocksProps;
  }
});
Object.defineProperty(exports, "__unstableSerializeAndClean", {
  enumerable: true,
  get: function () {
    return _serializer.__unstableSerializeAndClean;
  }
});
Object.defineProperty(exports, "children", {
  enumerable: true,
  get: function () {
    return _children.default;
  }
});
Object.defineProperty(exports, "cloneBlock", {
  enumerable: true,
  get: function () {
    return _factory.cloneBlock;
  }
});
Object.defineProperty(exports, "createBlock", {
  enumerable: true,
  get: function () {
    return _factory.createBlock;
  }
});
Object.defineProperty(exports, "createBlocksFromInnerBlocksTemplate", {
  enumerable: true,
  get: function () {
    return _factory.createBlocksFromInnerBlocksTemplate;
  }
});
Object.defineProperty(exports, "doBlocksMatchTemplate", {
  enumerable: true,
  get: function () {
    return _templates.doBlocksMatchTemplate;
  }
});
Object.defineProperty(exports, "findTransform", {
  enumerable: true,
  get: function () {
    return _factory.findTransform;
  }
});
Object.defineProperty(exports, "getBlockAttributes", {
  enumerable: true,
  get: function () {
    return _getBlockAttributes.getBlockAttributes;
  }
});
Object.defineProperty(exports, "getBlockAttributesNamesByRole", {
  enumerable: true,
  get: function () {
    return _utils.getBlockAttributesNamesByRole;
  }
});
Object.defineProperty(exports, "getBlockBindingsSource", {
  enumerable: true,
  get: function () {
    return _registration.getBlockBindingsSource;
  }
});
Object.defineProperty(exports, "getBlockBindingsSources", {
  enumerable: true,
  get: function () {
    return _registration.getBlockBindingsSources;
  }
});
Object.defineProperty(exports, "getBlockContent", {
  enumerable: true,
  get: function () {
    return _serializer.getBlockInnerHTML;
  }
});
Object.defineProperty(exports, "getBlockDefaultClassName", {
  enumerable: true,
  get: function () {
    return _serializer.getBlockDefaultClassName;
  }
});
Object.defineProperty(exports, "getBlockFromExample", {
  enumerable: true,
  get: function () {
    return _factory.getBlockFromExample;
  }
});
Object.defineProperty(exports, "getBlockMenuDefaultClassName", {
  enumerable: true,
  get: function () {
    return _serializer.getBlockMenuDefaultClassName;
  }
});
Object.defineProperty(exports, "getBlockSupport", {
  enumerable: true,
  get: function () {
    return _registration.getBlockSupport;
  }
});
Object.defineProperty(exports, "getBlockTransforms", {
  enumerable: true,
  get: function () {
    return _factory.getBlockTransforms;
  }
});
Object.defineProperty(exports, "getBlockType", {
  enumerable: true,
  get: function () {
    return _registration.getBlockType;
  }
});
Object.defineProperty(exports, "getBlockTypes", {
  enumerable: true,
  get: function () {
    return _registration.getBlockTypes;
  }
});
Object.defineProperty(exports, "getBlockVariations", {
  enumerable: true,
  get: function () {
    return _registration.getBlockVariations;
  }
});
Object.defineProperty(exports, "getCategories", {
  enumerable: true,
  get: function () {
    return _categories.getCategories;
  }
});
Object.defineProperty(exports, "getChildBlockNames", {
  enumerable: true,
  get: function () {
    return _registration.getChildBlockNames;
  }
});
Object.defineProperty(exports, "getDefaultBlockName", {
  enumerable: true,
  get: function () {
    return _registration.getDefaultBlockName;
  }
});
Object.defineProperty(exports, "getFreeformContentHandlerName", {
  enumerable: true,
  get: function () {
    return _registration.getFreeformContentHandlerName;
  }
});
Object.defineProperty(exports, "getGroupingBlockName", {
  enumerable: true,
  get: function () {
    return _registration.getGroupingBlockName;
  }
});
Object.defineProperty(exports, "getPhrasingContentSchema", {
  enumerable: true,
  get: function () {
    return _rawHandling.deprecatedGetPhrasingContentSchema;
  }
});
Object.defineProperty(exports, "getPossibleBlockTransformations", {
  enumerable: true,
  get: function () {
    return _factory.getPossibleBlockTransformations;
  }
});
Object.defineProperty(exports, "getSaveContent", {
  enumerable: true,
  get: function () {
    return _serializer.getSaveContent;
  }
});
Object.defineProperty(exports, "getSaveElement", {
  enumerable: true,
  get: function () {
    return _serializer.getSaveElement;
  }
});
Object.defineProperty(exports, "getUnregisteredTypeHandlerName", {
  enumerable: true,
  get: function () {
    return _registration.getUnregisteredTypeHandlerName;
  }
});
Object.defineProperty(exports, "hasBlockSupport", {
  enumerable: true,
  get: function () {
    return _registration.hasBlockSupport;
  }
});
Object.defineProperty(exports, "hasChildBlocks", {
  enumerable: true,
  get: function () {
    return _registration.hasChildBlocks;
  }
});
Object.defineProperty(exports, "hasChildBlocksWithInserterSupport", {
  enumerable: true,
  get: function () {
    return _registration.hasChildBlocksWithInserterSupport;
  }
});
Object.defineProperty(exports, "isReusableBlock", {
  enumerable: true,
  get: function () {
    return _registration.isReusableBlock;
  }
});
Object.defineProperty(exports, "isTemplatePart", {
  enumerable: true,
  get: function () {
    return _registration.isTemplatePart;
  }
});
Object.defineProperty(exports, "isUnmodifiedBlock", {
  enumerable: true,
  get: function () {
    return _utils.isUnmodifiedBlock;
  }
});
Object.defineProperty(exports, "isUnmodifiedDefaultBlock", {
  enumerable: true,
  get: function () {
    return _utils.isUnmodifiedDefaultBlock;
  }
});
Object.defineProperty(exports, "isValidBlockContent", {
  enumerable: true,
  get: function () {
    return _validation.isValidBlockContent;
  }
});
Object.defineProperty(exports, "isValidIcon", {
  enumerable: true,
  get: function () {
    return _utils.isValidIcon;
  }
});
Object.defineProperty(exports, "node", {
  enumerable: true,
  get: function () {
    return _node.default;
  }
});
Object.defineProperty(exports, "normalizeIconObject", {
  enumerable: true,
  get: function () {
    return _utils.normalizeIconObject;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parser.default;
  }
});
Object.defineProperty(exports, "parseWithAttributeSchema", {
  enumerable: true,
  get: function () {
    return _getBlockAttributes.parseWithAttributeSchema;
  }
});
Object.defineProperty(exports, "pasteHandler", {
  enumerable: true,
  get: function () {
    return _rawHandling.pasteHandler;
  }
});
exports.privateApis = void 0;
Object.defineProperty(exports, "rawHandler", {
  enumerable: true,
  get: function () {
    return _rawHandling.rawHandler;
  }
});
Object.defineProperty(exports, "registerBlockBindingsSource", {
  enumerable: true,
  get: function () {
    return _registration.registerBlockBindingsSource;
  }
});
Object.defineProperty(exports, "registerBlockCollection", {
  enumerable: true,
  get: function () {
    return _registration.registerBlockCollection;
  }
});
Object.defineProperty(exports, "registerBlockStyle", {
  enumerable: true,
  get: function () {
    return _registration.registerBlockStyle;
  }
});
Object.defineProperty(exports, "registerBlockType", {
  enumerable: true,
  get: function () {
    return _registration.registerBlockType;
  }
});
Object.defineProperty(exports, "registerBlockVariation", {
  enumerable: true,
  get: function () {
    return _registration.registerBlockVariation;
  }
});
Object.defineProperty(exports, "serialize", {
  enumerable: true,
  get: function () {
    return _serializer.default;
  }
});
Object.defineProperty(exports, "serializeRawBlock", {
  enumerable: true,
  get: function () {
    return _serializeRawBlock.serializeRawBlock;
  }
});
Object.defineProperty(exports, "setCategories", {
  enumerable: true,
  get: function () {
    return _categories.setCategories;
  }
});
Object.defineProperty(exports, "setDefaultBlockName", {
  enumerable: true,
  get: function () {
    return _registration.setDefaultBlockName;
  }
});
Object.defineProperty(exports, "setFreeformContentHandlerName", {
  enumerable: true,
  get: function () {
    return _registration.setFreeformContentHandlerName;
  }
});
Object.defineProperty(exports, "setGroupingBlockName", {
  enumerable: true,
  get: function () {
    return _registration.setGroupingBlockName;
  }
});
Object.defineProperty(exports, "setUnregisteredTypeHandlerName", {
  enumerable: true,
  get: function () {
    return _registration.setUnregisteredTypeHandlerName;
  }
});
Object.defineProperty(exports, "switchToBlockType", {
  enumerable: true,
  get: function () {
    return _factory.switchToBlockType;
  }
});
Object.defineProperty(exports, "synchronizeBlocksWithTemplate", {
  enumerable: true,
  get: function () {
    return _templates.synchronizeBlocksWithTemplate;
  }
});
Object.defineProperty(exports, "unregisterBlockBindingsSource", {
  enumerable: true,
  get: function () {
    return _registration.unregisterBlockBindingsSource;
  }
});
Object.defineProperty(exports, "unregisterBlockStyle", {
  enumerable: true,
  get: function () {
    return _registration.unregisterBlockStyle;
  }
});
Object.defineProperty(exports, "unregisterBlockType", {
  enumerable: true,
  get: function () {
    return _registration.unregisterBlockType;
  }
});
Object.defineProperty(exports, "unregisterBlockVariation", {
  enumerable: true,
  get: function () {
    return _registration.unregisterBlockVariation;
  }
});
Object.defineProperty(exports, "unstable__bootstrapServerSideBlockDefinitions", {
  enumerable: true,
  get: function () {
    return _registration.unstable__bootstrapServerSideBlockDefinitions;
  }
});
Object.defineProperty(exports, "updateCategory", {
  enumerable: true,
  get: function () {
    return _categories.updateCategory;
  }
});
Object.defineProperty(exports, "validateBlock", {
  enumerable: true,
  get: function () {
    return _validation.validateBlock;
  }
});
var _lockUnlock = require("../lock-unlock");
var _utils = require("./utils");
var _factory = require("./factory");
var _parser = _interopRequireDefault(require("./parser"));
var _serializeRawBlock = require("./parser/serialize-raw-block");
var _getBlockAttributes = require("./parser/get-block-attributes");
var _rawHandling = require("./raw-handling");
var _serializer = _interopRequireWildcard(require("./serializer"));
var _validation = require("./validation");
var _categories = require("./categories");
var _registration = require("./registration");
var _templates = require("./templates");
var _children = _interopRequireDefault(require("./children"));
var _node = _interopRequireDefault(require("./node"));
var _constants = require("./constants");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Internal dependencies
 */

// The blocktype is the most important concept within the block API. It defines
// all aspects of the block configuration and its interfaces, including `edit`
// and `save`. The transforms specification allows converting one blocktype to
// another through formulas defined by either the source or the destination.
// Switching a blocktype is to be considered a one-way operation implying a
// transformation in the opposite way has to be handled explicitly.

// The block tree is composed of a collection of block nodes. Blocks contained
// within other blocks are called inner blocks. An important design
// consideration is that inner blocks are -- conceptually -- not part of the
// territory established by the parent block that contains them.
//
// This has multiple practical implications: when parsing, we can safely dispose
// of any block boundary found within a block from the innerHTML property when
// transferring to state. Not doing so would have a compounding effect on memory
// and uncertainty over the source of truth. This can be illustrated in how,
// given a tree of `n` nested blocks, the entry node would have to contain the
// actual content of each block while each subsequent block node in the state
// tree would replicate the entire chain `n-1`, meaning the extreme end node
// would have been replicated `n` times as the tree is traversed and would
// generate uncertainty as to which one is to hold the current value of the
// block. For composition, it also means inner blocks can effectively be child
// components whose mechanisms can be shielded from the `edit` implementation
// and just passed along.

// While block transformations account for a specific surface of the API, there
// are also raw transformations which handle arbitrary sources not made out of
// blocks but producing block basaed on various heuristics. This includes
// pasting rich text or HTML data.

// The process of serialization aims to deflate the internal memory of the block
// editor and its state representation back into an HTML valid string. This
// process restores the document integrity and inserts invisible delimiters
// around each block with HTML comment boundaries which can contain any extra
// attributes needed to operate with the block later on.

// Validation is the process of comparing a block source with its output before
// there is any user input or interaction with a block. When this operation
// fails -- for whatever reason -- the block is to be considered invalid. As
// part of validating a block the system will attempt to run the source against
// any provided deprecation definitions.
//
// Worth emphasizing that validation is not a case of whether the markup is
// merely HTML spec-compliant but about how the editor knows to create such
// markup and that its inability to create an identical result can be a strong
// indicator of potential data loss (the invalidation is then a protective
// measure).
//
// The invalidation process can also be deconstructed in phases: 1) validate the
// block exists; 2) validate the source matches the output; 3) validate the
// source matches deprecated outputs; 4) work through the significance of
// differences. These are stacked in a way that favors performance and optimizes
// for the majority of cases. That is to say, the evaluation logic can become
// more sophisticated the further down it goes in the process as the cost is
// accounted for. The first logic checks have to be extremely efficient since
// they will be run for all valid and invalid blocks alike. However, once a
// block is detected as invalid -- failing the three first steps -- it is
// adequate to spend more time determining validity before throwing a conflict.

// Blocks are inherently indifferent about where the data they operate with ends
// up being saved. For example, all blocks can have a static and dynamic aspect
// to them depending on the needs. The static nature of a block is the `save()`
// definition that is meant to be serialized into HTML and which can be left
// void. Any block can also register a `render_callback` on the server, which
// makes its output dynamic either in part or in its totality.
//
// Child blocks are defined as a relationship that builds on top of the inner
// blocks mechanism. A child block is a block node of a particular type that can
// only exist within the inner block boundaries of a specific parent type. This
// allows block authors to compose specific blocks that are not meant to be used
// outside of a specified parent block context. Thus, child blocks extend the
// concept of inner blocks to support a more direct relationship between sets of
// blocks. The addition of parent–child would be a subset of the inner block
// functionality under the premise that certain blocks only make sense as
// children of another block.

// Templates are, in a general sense, a basic collection of block nodes with any
// given set of predefined attributes that are supplied as the initial state of
// an inner blocks group. These nodes can, in turn, contain any number of nested
// blocks within their definition. Templates allow both to specify a default
// state for an editor session or a default set of blocks for any inner block
// implementation within a specific block.

const privateApis = exports.privateApis = {};
(0, _lockUnlock.lock)(privateApis, {
  isContentBlock: _utils.isContentBlock
});
//# sourceMappingURL=index.js.map