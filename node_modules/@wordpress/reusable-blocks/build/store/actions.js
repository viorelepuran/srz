"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__experimentalDeleteReusableBlock = exports.__experimentalConvertBlocksToReusable = exports.__experimentalConvertBlockToStatic = void 0;
exports.__experimentalSetEditingReusableBlock = __experimentalSetEditingReusableBlock;
var _blockEditor = require("@wordpress/block-editor");
var _blocks = require("@wordpress/blocks");
var _i18n = require("@wordpress/i18n");
/**
 * WordPress dependencies
 */

/**
 * Returns a generator converting a reusable block into a static block.
 *
 * @param {string} clientId The client ID of the block to attach.
 */
const __experimentalConvertBlockToStatic = clientId => ({
  registry
}) => {
  const oldBlock = registry.select(_blockEditor.store).getBlock(clientId);
  const reusableBlock = registry.select('core').getEditedEntityRecord('postType', 'wp_block', oldBlock.attributes.ref);
  const newBlocks = (0, _blocks.parse)(typeof reusableBlock.content === 'function' ? reusableBlock.content(reusableBlock) : reusableBlock.content);
  registry.dispatch(_blockEditor.store).replaceBlocks(oldBlock.clientId, newBlocks);
};

/**
 * Returns a generator converting one or more static blocks into a pattern.
 *
 * @param {string[]}             clientIds The client IDs of the block to detach.
 * @param {string}               title     Pattern title.
 * @param {undefined|'unsynced'} syncType  They way block is synced, current undefined (synced) and 'unsynced'.
 */
exports.__experimentalConvertBlockToStatic = __experimentalConvertBlockToStatic;
const __experimentalConvertBlocksToReusable = (clientIds, title, syncType) => async ({
  registry,
  dispatch
}) => {
  const meta = syncType === 'unsynced' ? {
    wp_pattern_sync_status: syncType
  } : undefined;
  const reusableBlock = {
    title: title || (0, _i18n.__)('Untitled pattern block'),
    content: (0, _blocks.serialize)(registry.select(_blockEditor.store).getBlocksByClientId(clientIds)),
    status: 'publish',
    meta
  };
  const updatedRecord = await registry.dispatch('core').saveEntityRecord('postType', 'wp_block', reusableBlock);
  if (syncType === 'unsynced') {
    return;
  }
  const newBlock = (0, _blocks.createBlock)('core/block', {
    ref: updatedRecord.id
  });
  registry.dispatch(_blockEditor.store).replaceBlocks(clientIds, newBlock);
  dispatch.__experimentalSetEditingReusableBlock(newBlock.clientId, true);
};

/**
 * Returns a generator deleting a reusable block.
 *
 * @param {string} id The ID of the reusable block to delete.
 */
exports.__experimentalConvertBlocksToReusable = __experimentalConvertBlocksToReusable;
const __experimentalDeleteReusableBlock = id => async ({
  registry
}) => {
  const reusableBlock = registry.select('core').getEditedEntityRecord('postType', 'wp_block', id);

  // Don't allow a reusable block with a temporary ID to be deleted.
  if (!reusableBlock) {
    return;
  }

  // Remove any other blocks that reference this reusable block.
  const allBlocks = registry.select(_blockEditor.store).getBlocks();
  const associatedBlocks = allBlocks.filter(block => (0, _blocks.isReusableBlock)(block) && block.attributes.ref === id);
  const associatedBlockClientIds = associatedBlocks.map(block => block.clientId);

  // Remove the parsed block.
  if (associatedBlockClientIds.length) {
    registry.dispatch(_blockEditor.store).removeBlocks(associatedBlockClientIds);
  }
  await registry.dispatch('core').deleteEntityRecord('postType', 'wp_block', id);
};

/**
 * Returns an action descriptor for SET_EDITING_REUSABLE_BLOCK action.
 *
 * @param {string}  clientId  The clientID of the reusable block to target.
 * @param {boolean} isEditing Whether the block should be in editing state.
 * @return {Object} Action descriptor.
 */
exports.__experimentalDeleteReusableBlock = __experimentalDeleteReusableBlock;
function __experimentalSetEditingReusableBlock(clientId, isEditing) {
  return {
    type: 'SET_EDITING_REUSABLE_BLOCK',
    clientId,
    isEditing
  };
}
//# sourceMappingURL=actions.js.map