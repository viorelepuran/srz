/**
 * Find the next matching shortcode.
 *
 * @param {string} tag   Shortcode tag.
 * @param {string} text  Text to search.
 * @param {number} index Index to start search from.
 *
 * @return {import('./types').ShortcodeMatch | undefined} Matched information.
 */
export function next(tag: string, text: string, index?: number): import("./types").ShortcodeMatch | undefined;
/**
 * Replace matching shortcodes in a block of text.
 *
 * @param {string}                            tag      Shortcode tag.
 * @param {string}                            text     Text to search.
 * @param {import('./types').ReplaceCallback} callback Function to process the match and return
 *                                                     replacement string.
 *
 * @return {string} Text with shortcodes replaced.
 */
export function replace(tag: string, text: string, callback: import("./types").ReplaceCallback): string;
/**
 * Generate a string from shortcode parameters.
 *
 * Creates a shortcode instance and returns a string.
 *
 * Accepts the same `options` as the `shortcode()` constructor, containing a
 * `tag` string, a string or object of `attrs`, a boolean indicating whether to
 * format the shortcode using a `single` tag, and a `content` string.
 *
 * @param {Object} options
 *
 * @return {string} String representation of the shortcode.
 */
export function string(options: Object): string;
/**
 * Generate a RegExp to identify a shortcode.
 *
 * The base regex is functionally equivalent to the one found in
 * `get_shortcode_regex()` in `wp-includes/shortcodes.php`.
 *
 * Capture groups:
 *
 * 1. An extra `[` to allow for escaping shortcodes with double `[[]]`
 * 2. The shortcode name
 * 3. The shortcode argument list
 * 4. The self closing `/`
 * 5. The content of a shortcode when it wraps some content.
 * 6. The closing tag.
 * 7. An extra `]` to allow for escaping shortcodes with double `[[]]`
 *
 * @param {string} tag Shortcode tag.
 *
 * @return {RegExp} Shortcode RegExp.
 */
export function regexp(tag: string): RegExp;
/**
 * Generate a Shortcode Object from a RegExp match.
 *
 * Accepts a `match` object from calling `regexp.exec()` on a `RegExp` generated
 * by `regexp()`. `match` can also be set to the `arguments` from a callback
 * passed to `regexp.replace()`.
 *
 * @param {import('./types').Match} match Match array.
 *
 * @return {InstanceType<import('./types').shortcode>} Shortcode instance.
 */
export function fromMatch(match: import("./types").Match): InstanceType<import("./types").shortcode>;
export * from "./types";
/**
 * Parse shortcode attributes.
 *
 * Shortcodes accept many types of attributes. These can chiefly be divided into
 * named and numeric attributes:
 *
 * Named attributes are assigned on a key/value basis, while numeric attributes
 * are treated as an array.
 *
 * Named attributes can be formatted as either `name="value"`, `name='value'`,
 * or `name=value`. Numeric attributes can be formatted as `"value"` or just
 * `value`.
 *
 * @param {string} text Serialised shortcode attributes.
 *
 * @return {import('./types').ShortcodeAttrs} Parsed shortcode attributes.
 */
export const attrs: ((text?: any) => {
    named: {};
    numeric: string[];
}) & import("memize").MemizeMemoizedFunction;
export default shortcode;
/**
 * Creates a shortcode instance.
 *
 * To access a raw representation of a shortcode, pass an `options` object,
 * containing a `tag` string, a string or object of `attrs`, a string indicating
 * the `type` of the shortcode ('single', 'self-closing', or 'closed'), and a
 * `content` string.
 *
 * @type {import('./types').shortcode} Shortcode instance.
 */
declare const shortcode: import("./types").shortcode;
//# sourceMappingURL=index.d.ts.map